

@function __sort-predicate-asc($first, $second) {
  @return if($first > $second, 1, if($first < $second, -1, 0));
}

@function __sort-predicate-desc($first, $second) {
  @return if($first < $second, 1, if($first > $second, -1, 0));
}

@function __sort-iteratee($value, $index, $collection, $predicate, $args...) {
  @return __sort($value, $predicate);
}

/// Quick sort
/// @author Sam Richards
/// @param {List} $list - list to sort
/// @return {List}
@function __sort($list, $predicate: 'asc') {
    $predicate-map: (
        'asc': __sort-predicate-asc,
        'desc': __sort-predicate-desc
    );

    $comparison-function: __either(get($predicate-map, $predicate), $predicate);

    $less:  ();
    $equal: ();
    $large: ();

    @if length($list) > 1 {
    $seed: nth($list, ceil(length($list) / 2));

    @each $item in $list {
        $comparison: __exec($comparison-function, $item, $seed);

        @if $comparison == 0 {
            $equal: append($equal, $item);
        } @else if $comparison < 0 {
            $less: append($less, $item);
        } @else if $comparison > 0 {
            $large: append($large, $item);
        }
    }

    @return join(join(__sort($less, $predicate), $equal), __sort($large, $predicate));
    }

    @return $list;
}

@function _sort($args...) { @return call(__sort, $args...); }

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection through `iteratee`. This method performs
 * a stable sort, that is, it preserves the original sort order of equal elements.
 * The `iteratee` is bound to `thisArg` and invoked with three arguments;
 * (value, index|key, collection).
 *
 * If a property name is provided for `predicate` the created `_.property`
 * style callback returns the property value of the given element.
 *
 * If a value is also provided for `thisArg` the created `_.matchesProperty`
 * style callback returns `true` for elements that have a matching property
 * value, else `false`.
 *
 * If an object is provided for `predicate` the created `_.matches` style
 * callback returns `true` for elements that have the properties of the given
 * object, else `false`.
 *
 * @static
 * @memberOf _
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Array|Function|Object|string} [iteratee=_.identity] The function
 *  invoked per iteration. If a property name or an object is provided it is
 *  used to create a `_.property` or `_.matches` style callback respectively.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * _.sortBy([1, 2, 3], function(n) {
 *   return Math.sin(n);
 * });
 * // => [3, 1, 2]
 *
 * _.sortBy([1, 2, 3], function(n) {
 *   return this.sin(n);
 * }, Math);
 * // => [3, 1, 2]
 *
 * var users = [
 *   { 'user': 'fred' },
 *   { 'user': 'pebbles' },
 *   { 'user': 'barney' }
 * ];
 *
 * // using the `_.property` callback shorthand
 * _.pluck(_.sortBy(users, 'user'), 'user');
 * // => ['barney', 'fred', 'pebbles']
 */
@function _sort-by($args...) { @return call(__sort-by, $args...); }

/**
 * This method is like `_.sortBy` except that it sorts by property names
 * instead of an iteratee function.
 *
 * @static
 * @memberOf _
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {...(string|string[])} props The property names to sort by,
 *  specified as individual property names or arrays of property names.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 26 },
 *   { 'user': 'fred',   'age': 30 }
 * ];
 *
 * _.map(_.sortByAll(users, ['user', 'age']), _.values);
 * // => [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
 */
@function _sort-by-all($args...) { @return call(__sort-by-all, $args...); }