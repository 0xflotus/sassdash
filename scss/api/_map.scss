

@function __base-map-iteratee($value, $key, $collection) {
    $result: this('result');
    $iteratee: this('iteratee');

    $result: append($result, __exec($iteratee, $value, $key, $collection));
    $_: this('result', $result);

    @return $result;
}
@function __base-map($collection, $iteratee) {
    $_: __scope();
    $_: scope('result', ());
    $_: scope('iteratee', $iteratee);

    $_: __base-each($collection, __base-map-iteratee);

    $result: scope('result');
    $_: __scope(false);

    @return $result;
}

@function __list-map($list, $iteratee) {
    $index: 1;
    $length: length($list);
    $result-list: ();

    @while ($index <= $length) {
        $value: nth($list, $index);

        $result-list: append($result-list, __exec($iteratee, $value, $index, $list));

        $index: $index + 1;
    }

    @return $result-list;
}

@function __map($collection, $iteratee: __identity, $this-arg: null) {
    @if not __is-iterable($collection) {
        $collection: ();
    }

    $collection: if(__is-string($collection), __to-list($collection), $collection);
    $function: if(__is-list($collection), __list-map, __base-map);

    $iteratee: __get-callback($iteratee, $this-arg, 3);

    @return __exec($function, $collection, $iteratee);
}


@function __map-values-iteratee($value, $key, $map) {
    $result: __this('result');
    $iteratee: __this('iteratee');

    $result: set($result, $key, __exec($iteratee, $value, $key, $map));

    $_: __this('result', $result);

    @return true;
}
@function __map-values($map, $iteratee: __identity, $this-arg: null) {
    $result: ();
    $iteratee: __get-callback($iteratee, $this-arg, 3);

    $_: __scope(('result': $result, 'iteratee': $iteratee));

    $map-values-iteratee: __bind(__map-values-iteratee);

    $_: __base-for-own($map, $map-values-iteratee);

    $result: scope('result');
    $_: __scope(false);

    @return $result;
}

/// 
/// Creates an array of values by running each element in `collection` through
/// `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
/// arguments; (value, index|key, collection).
/// If a property name is provided for `predicate` the created `_property`
/// style callback returns the property value of the given element.
/// If a value is also provided for `thisArg` the created `_matches-property`
/// style callback returns `true` for elements that have a matching property
/// value, else `false`.
/// If an object is provided for `predicate` the created `_matches` style
/// callback returns `true` for elements that have the properties of the given
/// object, else `false`.
/// Many lodash methods are guarded to work as interatees for methods like
/// `_every`, `_filter`, `_map`, `_map-values`, `_reject`, and `_some`.
/// The guarded methods are:
/// `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`, `drop`,
/// `dropRight`, `fill`, `flatten`, `invert`, `max`, `min`, `parseInt`, `slice`,
/// `sortBy`, `take`, `takeRight`, `template`, `trim`, `trimLeft`, `trimRight`,
/// `trunc`, `random`, `range`, `sample`, `uniq`, and `words`
/// @static
/// @memberOf _
/// @alias collect
/// @category Collection
/// @param {Array|Object|string} collection The collection to iterate over.
/// @param {Function|Object|string} (iteratee=_.identity) The function invoked
///  per iteration.
///  create a `_property` or `_matches` style callback respectively.
/// @param {*} (thisArg) The `this` binding of `iteratee`.
/// @returns {Array} Returns the new mapped array.
/// @example
/// function timesThree(n) {
///   return n/// 3;
/// }
/// _map((1, 2), timesThree);
/// // => (3, 6)
/// _map({ 'a': 1, 'b': 2 }, timesThree);
/// // => (3, 6) (iteration order is not guaranteed)
/// var users = [
///   { 'user': 'barney' },
///   { 'user': 'fred' }
/// ];
/// // using the `_property` callback shorthand
/// _map(users, 'user');
/// // => ('barney', 'fred')
/// 
@function _map($args...) { @return call(__map, $args...); }

@function _collect($args...) { @return call(__map, $args...); }

/// 
/// Creates an object with the same keys as `object` and values generated by
/// running each own enumerable property of `object` through `iteratee`. The
/// iteratee function is bound to `thisArg` and invoked with three arguments;
/// (value, key, object).
/// If a property name is provided for `iteratee` the created `_property`
/// style callback returns the property value of the given element.
/// If a value is also provided for `thisArg` the created `_matches-property`
/// style callback returns `true` for elements that have a matching property
/// value, else `false`.
/// If an object is provided for `iteratee` the created `_matches` style
/// callback returns `true` for elements that have the properties of the given
/// object, else `false`.
/// @static
/// @memberOf _
/// @category Object
/// @param {Object} object The object to iterate over.
/// @param {Function|Object|string} (iteratee=_.identity) The function invoked
///  per iteration.
/// @param {*} (thisArg) The `this` binding of `iteratee`.
/// @returns {Object} Returns the new mapped object.
/// @example
/// _map-values({ 'a': 1, 'b': 2 }, function(n) {
///   return n/// 3;
/// });
/// // => { 'a': 3, 'b': 6 }
/// var users = {
///   'fred':    { 'user': 'fred',    'age': 40 },
///   'pebbles': { 'user': 'pebbles', 'age': 1 }
/// };
/// // using the `_property` callback shorthand
/// _map-values(users, 'age');
/// // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
/// 
@function _map-values($args...) { @return call(__map-values, $args...); }