@function __count-by-iteratee($result, $value, $key, $args...) {
    $result: if(
        map-has-key($result, $key),
        set($result, $key, __get($result, $key) + 1),
        set($result, $key, 1));

    @return $result;
}
@function __count-by($arguments...) {
    $function: __create-aggregator(__count-by-iteratee);

    @return __exec($function, $arguments...);
}

/// 
/// Creates an object composed of keys generated from the results of running
/// each element of `collection` through `iteratee`. The corresponding value
/// of each key is the number of times the key was returned by `iteratee`.
/// The `iteratee` is bound to `thisArg` and invoked with three arguments;
/// (value, index|key, collection).
/// If a property name is provided for `predicate` the created `_property`
/// style callback returns the property value of the given element.
/// If a value is also provided for `thisArg` the created `_matches-property`
/// style callback returns `true` for elements that have a matching property
/// value, else `false`.
/// If an object is provided for `predicate` the created `_matches` style
/// callback returns `true` for elements that have the properties of the given
/// object, else `false`.
/// @static
/// @memberOf _
/// @category Collection
/// @param {Array|Object|string} collection The collection to iterate over.
/// @param {Function|Object|string} (iteratee=_.identity) The function invoked
///  per iteration.
/// @param {*} (thisArg) The `this` binding of `iteratee`.
/// @returns {Object} Returns the composed aggregate object.
/// @example
/// _count-by((4.3, 6.1, 6.4), function(n) {
///   return Math.floor(n);
/// });
/// // => { '4': 1, '6': 2 }
/// _count-by((4.3, 6.1, 6.4), function(n) {
///   return this.floor(n);
/// }, Math);
/// // => { '4': 1, '6': 2 }
/// _count-by(('one', 'two', 'three'), 'length');
/// // => { '3': 2, '5': 1 }
/// 
@function _count-by($args...) { @return call(__count-by, $args...); }
