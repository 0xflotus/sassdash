@import '../bower_components/true/sass/_true';
@import '../scss/_sassdash';

$true-terminal-output: true;

$test-falsey: ('', 0, false, null);
$test-empty-list: ();

@function test-add($x, $y) {
    @return $x + $y;
}

@function test-square($n, $args...) {
    @return $n * $n;
}

@function test-fixed($n) {
    @return __number-to-fixed($n);
}

@function test-is-even($n, $args...) {
    @return $n % 2 == 0;
}

@function test-floor($n, $args...) {
  @return floor($n);
}

@function test-args($args...) {
  @return $args;
}

@mixin test-group() { @content; }

@function test-take-right-1($value, $args...) {
  @return $value < 9;
}
@include test-module('Sassdash') {
  @include test('_take-right') {
    $list: 1 2 3;

    $actual: _take-right($list, 2);
    $expected: 2 3;

    @include assert-equal($actual, $expected,
      'should take the last two elements');

    @each $value in $test-falsey {
      $actual: _take-right($list, $value);
      $expected: if($value == null, (3,), $test-empty-list);

      @include assert-equal($actual, $expected,
        'should treat falsey n value, except nullish, as 0');
    }

    @each $value in 0, -1, -9999 {
      @include assert-equal(_take-right($list, $value), $test-empty-list,
        'should return an empty list when n < 1');
    }

    @each $value in 3, 4, pow(2, 32), 9999 {
      @include assert-equal(_take-right($list, $value), $list,
        'should return all elements when n >= list length');
    }

    @include test-group() {
      $list: 1 2 3, 4 5 6, 7 8 9;
      $actual: _map($list, _take-right);
      $expected: (3,), (6,), (9,);

      @include assert-equal($actual, $expected,
        'should work as iteratee for map');
    }

    @include test-group() {
      $list: 1 2 3 4 5 6 7 8 9 10;
      $predicate: test-take-right-1;
      $actual: _($list, take-right 2, take-right, value);

      @include assert-equal($actual, (10,),
        'should work in a lazy chain sequence');

      $actual: _($list, filter $predicate, take-right 2, take-right, value);

      @include assert-equal($actual, (8,),
        'should work in a lazy chain sequence');

      $actual: _($list, take-right 6, take 4, take-right 2, take, value);

      @include assert-equal($actual, (7,),
        'should work in a lazy chain sequence');

      $actual: _($list, filter $predicate, take-right 6, take 4, take-right 2, take, value);

      @include assert-equal($actual, (5,),
        'should work in a lazy chain sequence');
    }
  }
}

@function test-take-right-while-1($num, $args...) {
  @return $num > 1;
}
@include test-module('Sassdash') {
  @include test('_take-right-while') {  
    $list: 1 2 3;
    $maps: (
      ('a': 0, 'b': 0),
      ('a': 1, 'b': 1),
      ('a': 2, 'b': 2),
    );

    $actual: _take-right-while($list, test-take-right-while-1);

    @include assert-equal($actual, 2 3,
      'should take elements while predicate returns truthy');

    @include assert-true(true, 'should provide the correct predicate arguments'); // not implemented

    @include assert-true(true, 'should support the this-arg argument'); // todo

    @include assert-equal(_take-right-while($maps, 'b'), _slice($maps, 1),
      'should work with a _pluck style predicate');

    @include assert-equal(_take-right-while($maps, ('b': 2)), _slice($maps, 2),
      'should work with a _where style predicate');

    @include assert-equal(_($list, take-right-while test-take-right-while-1, value), 2 3,
      'should return expected value when chaining');
  }
}

@function test-take-while-1($num, $args...) {
  @return $num < 3;
}
@include test-module('Sassdash') {
  @include test('_take-while') {  
    $list: 1 2 3;
    $maps: (
      ('a': 2, 'b': 2),
      ('a': 1, 'b': 1),
      ('a': 0, 'b': 0),
    );

    $actual: _take-while($list, test-take-while-1);

    @include assert-equal($actual, 1 2,
      'should take elements while predicate returns truthy');

    @include assert-true(true, 'should provide the correct predicate arguments'); // not implemented

    @include assert-true(true, 'should support the this-arg argument'); // todo

    @include assert-equal(_take-while($maps, 'b'), _slice($maps, 0, 2),
      'should work with a _pluck style predicate');

    @include assert-equal(_take-while($maps, ('b': 2)), _slice($maps, 0, 1),
      'should work with a _where style predicate');

    @include assert-equal(_($list, take-while test-take-while-1, value), 1 2,
      'should return expected value when chaining');
  }
}

@function test-flatten-1($args...) {
  @return $args;
}
@include test-module('Sassdash') {
  $args: test-flatten-1(1, 2, 3);

  @include test('flatten methods') {
    $list: ((('a',),), (('b',),));

    @include assert-equal(_flatten($list), (('a',), ('b',)),
      'should perform a shallow flatten');

    $expected: ('a', 'b');

    @include assert-equal(_flatten($list, true), $expected,
      'should work with isDeep');

    @include assert-equal(_flatten-deep($list), $expected,
      'should work with isDeep');

    $list: ($args, ($args,));
    $expected: (1, 2, 3, $args);

    @include assert-equal(_flatten($list), $expected,
      'should flatten arglists');

    $expected: (1, 2, 3, 1, 2, 3);

    @include assert-equal(_flatten($list, true), $expected,
      'should flatten arglists');

    @include assert-equal(_flatten-deep($list), $expected,
      'should flatten arglists');

    $list: (((('a',),),), ((('b',),),));

    @include assert-equal(_map($list, _flatten), ((('a',),), (('b',),)),
      'should work as an iteratee for _map');

    @include assert-equal(_map($list, _flatten-deep), (('a',), ('b',)),
      'should work as an iteratee for _map');
    
    $list: ((), ((),), ((), (((),),),));
    $expected: ((), (), (((),),));

    @include assert-equal(_flatten($list), $expected,
      'should work with empty lists');

    @include assert-equal(_flatten($list, true), $test-empty-list,
      'should work with empty lists');

    @include assert-equal(_flatten-deep($list), $test-empty-list,
      'should work with empty lists');

    $list: (1, (2,), (3, (4,)));
    $expected: (1, 2, 3, (4,));

    @include assert-equal(_flatten($list), $expected,
      'should support flattening of nested lists');

    $expected: (1, 2, 3, 4);

    @include assert-equal(_flatten($list, true), $expected,
      'should support flattening of nested lists');

    @include assert-equal(_flatten-deep($list), $expected,
      'should support flattening of nested lists');

    $expected: ();

    @include assert-equal(_flatten(('a': 1)), $expected,
      'should return empty list for non list-like objects');

    @include assert-equal(_flatten(('a': 1), true), $expected,
      'should return empty list for non list-like objects');

    @include assert-equal(_flatten-deep(('a': 1)), $expected,
      'should return empty list for non list-like objects');
  }
}

@include test-module('Sassdash') {
  @include test('_for-each') {
    @include assert-equal(_each(1 2 3, test-square), _for-each(1 2 3, test-square),
      'should be aliased');
  }

  @include test('_for-each-right') {
    @include assert-equal(_each-right(1 2 3, test-square), _for-each-right(1 2 3, test-square),
      'should be aliased');
  }
}

// @include test-module('Sassdash iteration methods') {
//   $methods: (
//     'count-by',
//     'every',
//     'filter',
//     'find',
//     'find-index',
//     'find-key',
//     'find-last',
//     'find-last-index',
//     'find-last-key',
//     'for-each-right',
//     'for-in',
//     'for-in-right',
//     'for-own',
//     'for-own-right',
//     'group-by',
//     'index-by',
//     'map',
//     'max',
//     'min',
//     'partition',
//     'reject',
//     'some'
//   );

//   $array-methods: (
//     'find-index',
//     'find-last-index'
//   );

//   $collection-methods: (
//     'count-by',
//     'every',
//     'filter',
//     'find',
//     'find-last',
//     'for-each',
//     'for-each-right',
//     'group-by',
//     'index-by',
//     'map',
//     'max',
//     'min',
//     'partition',
//     'reduce',
//     'reduce-right',
//     'reject',
//     'some'
//   );

//   $for-in-methods: (
//     'for-in',
//     'for-in-right'
//   );

//   $iteration-methods: (
//     'for-each',
//     'for-each-right',
//     'for-in',
//     'for-in-right',
//     'for-own',
//     'for-own-right'
//   );

//   $map-methods: (
//     'find-key',
//     'find-last-key',
//     'for-in',
//     'for-in-right',
//     'for-own',
//     'for-own-right'
//   );

//   $right-methods: (
//     'find-last',
//     'find-last-index',
//     'find-last-key',
//     'for-each-right',
//     'for-in-right',
//     'for-own-right'
//   );

//   $unwrapped-methods: (
//     'every',
//     'find',
//     'find-index',
//     'find-key',
//     'find-last',
//     'find-last-index',
//     'find-last-key',
//     'max',
//     'min',
//     'some'
//   );
// }

@include test-module('Sassdash') {
  @include test('map assignments') {  
    // TODO: add 'merge'
    @each $method-name in 'assign', 'defaults' {
      $func: unquote('_#{$method-name}');

      @each $value in $test-falsey {
        $actual: _call($func, null, $value);
        $expected: $value;

        @include assert-equal($actual, $expected,
          '#{$func} should pass thru falsey map values');
      }

      $list: (('b': 2), ('c': 3));
      $actual: _reduce($list, $func, ('a': 1));
      $expected: ('a': 1, 'b': 2, 'c': 3);

      @include assert-equal($actual, $expected,
        '#{$func} should work as an iteratee for _reduce');
    }
  }
}

// @include test-module('Sassdash') {
//   @include test('_merge') {
//     $names: (
//       'characters': (
//         ('name': 'barney'),
//         ('name': 'fred')
//       )
//     );

//     $ages: (
//       'characters': (
//         ('age': 36),
//         ('age': 40)
//       )
//     );

//     $heights: (
//       'characters': (
//         ('height': '5ft4'),
//         ('height': '5ft5')
//       )
//     );

//     $expected: (
//       'characters': (
//         ('name': 'barney', 'age': 36, 'height': '5ft4'),
//         ('name': 'fred', 'age': 40, 'height': '5ft5')
//       )
//     );

//     @include assert-equal(_merge($names, $ages, $heights), $expected
//       'should merge source into the destination object');
//   }
// }

@include test-module('Sassdash') {
  @include test('_min') {
    @include assert-equal(_min(1 2 3), 1,
      'should return the smallest value from a collection');

    @include assert-equal(_min(()), const-get('POSITIVE_INFINITY'),
      'should return Infinity for empty collections');

    @include assert-equal(_min(('a' 'b') ('a': 'a', 'b': 'b')), const-get('POSITIVE_INFINITY'),
      'should return Infinity for non-numeric collection items');
  }
}

@function test-maxmin-1($num, $args...) {
  @return -$num;
}
@include test-module('Sassdash') {
  @include test('_max and _min') {
    @each $method-name in 'max', 'min' {
      $list: 1 2 3;
      $func: unquote('_#{$method-name}');
      $is-max: $method-name == 'max';

      @include assert-equal(_call($func, null, $list, test-maxmin-1), if($is-max, 1, 3),
        'should work with an iteratee argument');

      $maps: (('a': 2), ('a': 3), ('a': 1));
      $actual: _call($func, null, $maps, 'a');

      @include assert-equal($actual, nth($maps, if($is-max, 2, 3)),
        'should work with _pluck style iteratee');

      $actual: _call($func, null, ('a': 1, 'b': 2, 'c': 3));

      @include assert-equal($actual, if($is-max, 3, 1),
        'should iterate a map');

      @include assert-equal(_call($func, null, 'abc'), if($is-max, 'c', 'a'),
        'should iterate a string');

      $list: (2 3 1, 5 6 4, 8 9 7);
      $actual: _map($list, $func);

      @include assert-equal($actual, if($is-max, 3 6 9, 1 4 7),
        '#{$func} should work as an iteratee for _map');

      @include assert-equal(_map('abc', $func), 'a' 'b' 'c',
        '#{$func} should work as an iteratee for _map');

      @include assert-equal(_((40,), $method-name), 40,
        'should work when chaining on a list with only one value');
    }
  }
}

@include test-module('Sassdash') {
  @include test('_negate') {
    $negate: _negate(test-is-even);

    @include assert-equal(_call($negate, null, 1), true,
      'should create a function that negates the result of func');

    @include assert-equal(_call($negate, null, 2), false,
      'should create a function that negates the result of func');
  }
}

@include test-module('Sassdash') {
  @include test('_noop') {
    @include assert-equal(_noop(1, 2, 3), null,
      'should return null');
  }
}

@include test-module('Sassdash') {
  @include test('_omit') {
    $map: ('a': 1, 'b': 2, 'c': 3);
    $expected: ('b': 2);

    @include assert-equal(_omit($map, 'a'), ('b': 2, 'c': 3),
      'should create a map with omitted properties');

    @include assert-equal(_omit($map, 'a', 'c'), $expected,
      'should create a map with omitted properties');

    @include assert-equal(_omit($map, 'a' 'c'), $expected,
      'should support picking a list of properties');

    @include assert-equal(_omit($map, ('a',), 'c'), $expected,
      'should support picking a list of properties and individual properties');

    @include assert-equal(_omit(null, 'test'), (),
      'should return an empty map when map is null');

    $args: test-args('a', 'c');

    @include assert-equal(_omit($map, $args), $expected,
      'should work with arglists as secondary arguments');

    @include assert-equal(_omit(1 2 3, 1, 3), (2: 2),
      'should work with a list map argument');
    
    // TODO: investigate failing test
    // @include assert-equal(_omit($map, test-is-even), ('a': 1, 'c': 3),
    //   'should work with a predicate argument');
  }
}

@include test-module('Sassdash') {
  @include test('_once') {
    $once: _once(test-square);
    $actual: _call($once, null, 2);

    @include assert-equal($actual, 4,
      'should invoke func once');

    $actual: _call($once, null, 2);

    @include assert-equal($actual, null,
      'should invoke func once');
  }
}

@include test-module('Sassdash') {
  @include test('_pad') {
    @include assert-equal(_pad('abc', 9), '   abc   ',
      'should pad a string to a given length');

    @include assert-equal(_pad('abc', 8), '  abc   ',
      'should truncate pad characters to fit the pad length');

    @include assert-equal(_pad('abc', 8, '_-'), '_-abc_-_',
      'should truncate pad characters to fit the pad length');

    @include assert-equal(_pad(123, 9), '   123   ',
      'should coerce to a string');
  }

  @include test('_pad-left') {
    @include assert-equal(_pad-left('abc', 9), '      abc',
      'should pad a string to a given length');

    @include assert-equal(_pad-left('abc', 6, '_-'), '_-_abc',
      'should truncate pad characters to fit the pad length');

    @include assert-equal(_pad-left(123, 4), ' 123',
      'should coerce to a string');
  }

  @include test('_pad-right') {
    @include assert-equal(_pad-right('abc', 9), 'abc      ',
      'should pad a string to a given length');

    @include assert-equal(_pad-right('abc', 6, '_-'), 'abc_-_',
      'should truncate pad characters to fit the pad length');

    @include assert-equal(_pad-right(123, 4), '123 ',
      'should coerce to a string');
  }

  @include test('_pad methods') {
    @each $method-name in 'pad', 'pad-left', 'pad-right' {
      $func: unquote('_#{$method-name}');
      $is-pad-left: $method-name == 'pad-left';

      @include assert-equal(_call($func, null, 'abc', 2), 'abc',
        'should not pad if string is >= length');

      @include assert-equal(_call($func, null, 'abc', 3), 'abc',
        'should not pad if string is >= length');

      @include assert-equal(_call($func, null, 'abc', 0), 'abc',
        'should treat negative length as 0');

      @include assert-equal(_call($func, null, 'abc', -3), 'abc',
        'should treat negative length as 0');

      @include assert-equal(_call($func, null, null, 0, null), '',
        'should return an empty string when provided null or empty string and chars');

      @include assert-equal(_call($func, null, null, 0, '_-'), '',
        'should return an empty string when provided null or empty string and chars');

      @include assert-equal(_call($func, null, '', 0, null), '',
        'should return an empty string when provided null or empty string and chars');

      @include assert-equal(_call($func, null, '', 0, '_-'), '',
        'should return an empty string when provided null or empty string and chars');

      @include assert-equal(_call($func, null, 'abc', 6, null), 'abc',
        'should work with null or empty string for chars');

      @include assert-equal(_call($func, null, 'abc', 6, ''), 'abc',
        'should work with null or empty string for chars');
    }
  }
}

@include test-module('Sassdash') {
  @include test('_pairs') {
    $map: ('a': 1, 'b': 2);

    @include assert-equal(_pairs($map), (('a', 1), ('b', 2)),
      'should create a 2d list of key-value pairs');
  }
}

// todo _parseint

@function test-partial-1($a, $b) {
  @return ($a, $b);
}
@function test-partial-2($args...) {
  @return length($args);
}
@include test-module('Sassdash') {
  @include test('_partial methods') {
    @each $method-name in 'partial', 'partial-right' {
      $func: unquote('_#{$method-name}');
      $is-partial: $method-name == 'partial';

      $par: _call($func, null, _identity, 'a');

      @include assert-equal(_call($par), 'a',
        '#{$func} partially applies arguments');

      $expected: ('a', 'b');
      $par: _call($func, null, test-partial-1, 'a');

      @include assert-equal(_call($par, null, 'b'), if($is-partial, $expected, __list-reverse($expected)),
        '#{$func} creates a function that can be invoked with additional arguments');

      $par: _call($func, null, test-partial-2);

      @include assert-equal(_call($par), 0,
        '#{$func} works when there are no partially applied arguments and the created function is invoked without additional arguments');

      $par: _call($func, null, _identity);

      @include assert-equal(_call($par, null, 'a'), 'a',
        '#{$func} works when there are no partially applied arguments and the created function is invoked with additional arguments');
    }
  }
}

@include test-module('Sassdash') {
  @include test('_partition') {
    $list: 1 0 1;

    @include assert-equal(_partition((), _identity), ((), ()),
      'should return two groups of elements');

    @include assert-equal(_partition($list, _constant(true)), ($list, ()),
      'should return two groups of elements');

    @include assert-equal(_partition($list, _constant(false)), ((), $list),
      'should return two groups of elements');

    $expected: (1 1), (0,);

    @include assert-equal(_partition($list, null), $expected,
      'should use _identity when predicate is nullish');

    @include assert-equal(_partition($list), $expected,
      'should use _identity when predicate is nullish');

    // todo: should support the this-arg argument

    $maps: (('a': 1), ('a': 1), ('b': 2));
    $expected: _slice($maps, 0, 2), _slice($maps, 2);

    @include assert-equal(_partition($maps, 'a'), $expected,
      'should work with a _pluck style predicate');

    $list: (1 0, 0 1, 1 0);
    $expected: ((1 0, 1 0), (0 1,));

    @include assert-equal(_partition($list, 1), $expected,
      'should work with a number for predicate');

    $map: ('a': 1.1, 'b': 0.2, 'c': 1.3);

    @include assert-equal(_partition($map, test-floor), ((1.1, 1.3), (0.2,)),
      'should work with map for collection');
  }
}

@include test-module('Sassdash') {
  $map: ('a': 1, 'b': 2, 'c': 3);
  $expected: ('a': 1, 'c': 3);

  @include test('_pick') {  
    @include assert-equal(_pick($map, 'a'), ('a': 1),
      'should create a map of picked properties');

    @include assert-equal(_pick($map, 'a' 'c'), $expected,
      'should support picking a list of properties');

    @include assert-equal(_pick($map, ('a',), 'c'), $expected,
      'should support picking a list of properties and individual properties');

    @include assert-equal(_pick(null, 'something'), (),
      'should return an empty map when map is null');

    $args: test-args('a', 'c');
    @include assert-equal(_pick($map, $args), $expected,
      'should work with arglist as secondary arguments');

    @include assert-equal(_pick(1 2 3, 2), (2: 2),
      'should work with a list map argument');

    @include assert-equal(_pick($map, test-is-even), ('b': 2),
      'should work with a predicate argument');
  }
}

@include test-module('Sassdash') {
  @include test('_pluck') {
    $maps: (
      ('name': 'barney', 'age': 36),
      ('name': 'fred', 'age': 40)
    );

    @include assert-equal(_pluck($maps, 'name'), ('barney', 'fred'),
      'should return a list of property values from each element of a collection');

    $map: ('a': (1: 'one'), 'b': (1: 'two'), 'c': (1: 'three'));

    @include assert-equal(_pluck($map, 1), ('one' 'two' 'three'),
      'should work with a map for collection');

    $list: (('a': 1),);

    @include assert-equal(_pluck($list, 'b'), (null,),
      'should return null for undefined properties');

    $maps: (('a': 1), null, false, ('a': 4));

    @include assert-equal(_pluck($maps, 'a'), (1 null null 4),
      'should work with nullish elements');

    $list: (('a': 1), null, ('a': 3), ('a': 4));
    $actual: _($list, pluck 'a', value);

    @include assert-equal($actual, 1 null 3 4,
      'should work in a lazy chain sequence');

    @include assert-equal(_($list, filter _identity, pluck 'a', value), 1 3 4,
      'should work in a lazy chain sequence');
  }
}


@include report;