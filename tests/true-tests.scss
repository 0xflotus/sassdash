@import '../bower_components/true/sass/_true';
@import '../scss/_sassdash';

$true-terminal-output: true;

$test-falsey: ('', 0, false, null);
$test-empty-list: ();

@function test-add($x, $y, $args...) {
    @return $x + $y;
}

@function test-square($n, $args...) {
    @return $n * $n;
}

@function test-fixed($n) {
    @return __number-to-fixed($n);
}

@function test-is-even($n, $args...) {
    @return $n % 2 == 0;
}

@function test-floor($n, $args...) {
  @return floor($n);
}

@function test-args($args...) {
  @return $args;
}

@mixin test-group() { @content; }

@function test-take-right-1($value, $args...) {
  @return $value < 9;
}
@include test-module('Sassdash') {
  @include test('_take-right') {
    $list: 1 2 3;

    $actual: _take-right($list, 2);
    $expected: 2 3;

    @include assert-equal($actual, $expected,
      'should take the last two elements');

    @each $value in $test-falsey {
      $actual: _take-right($list, $value);
      $expected: if($value == null, (3,), $test-empty-list);

      @include assert-equal($actual, $expected,
        'should treat falsey n value, except nullish, as 0');
    }

    @each $value in 0, -1, -9999 {
      @include assert-equal(_take-right($list, $value), $test-empty-list,
        'should return an empty list when n < 1');
    }

    @each $value in 3, 4, pow(2, 32), 9999 {
      @include assert-equal(_take-right($list, $value), $list,
        'should return all elements when n >= list length');
    }

    @include test-group() {
      $list: 1 2 3, 4 5 6, 7 8 9;
      $actual: _map($list, _take-right);
      $expected: (3,), (6,), (9,);

      @include assert-equal($actual, $expected,
        'should work as iteratee for map');
    }

    @include test-group() {
      $list: 1 2 3 4 5 6 7 8 9 10;
      $predicate: test-take-right-1;
      $actual: _($list, take-right 2, take-right, value);

      @include assert-equal($actual, (10,),
        'should work in a lazy chain sequence');

      $actual: _($list, filter $predicate, take-right 2, take-right, value);

      @include assert-equal($actual, (8,),
        'should work in a lazy chain sequence');

      $actual: _($list, take-right 6, take 4, take-right 2, take, value);

      @include assert-equal($actual, (7,),
        'should work in a lazy chain sequence');

      $actual: _($list, filter $predicate, take-right 6, take 4, take-right 2, take, value);

      @include assert-equal($actual, (5,),
        'should work in a lazy chain sequence');
    }
  }
}

@function test-take-right-while-1($num, $args...) {
  @return $num > 1;
}
@include test-module('Sassdash') {
  @include test('_take-right-while') {  
    $list: 1 2 3;
    $maps: (
      ('a': 0, 'b': 0),
      ('a': 1, 'b': 1),
      ('a': 2, 'b': 2),
    );

    $actual: _take-right-while($list, test-take-right-while-1);

    @include assert-equal($actual, 2 3,
      'should take elements while predicate returns truthy');

    @include assert-true(true, 'should provide the correct predicate arguments'); // not implemented

    @include assert-true(true, 'should support the this-arg argument'); // todo

    @include assert-equal(_take-right-while($maps, 'b'), _slice($maps, 1),
      'should work with a _pluck style predicate');

    @include assert-equal(_take-right-while($maps, ('b': 2)), _slice($maps, 2),
      'should work with a _where style predicate');

    @include assert-equal(_($list, take-right-while test-take-right-while-1, value), 2 3,
      'should return expected value when chaining');
  }
}

@function test-take-while-1($num, $args...) {
  @return $num < 3;
}
@include test-module('Sassdash') {
  @include test('_take-while') {  
    $list: 1 2 3;
    $maps: (
      ('a': 2, 'b': 2),
      ('a': 1, 'b': 1),
      ('a': 0, 'b': 0),
    );

    $actual: _take-while($list, test-take-while-1);

    @include assert-equal($actual, 1 2,
      'should take elements while predicate returns truthy');

    @include assert-true(true, 'should provide the correct predicate arguments'); // not implemented

    @include assert-true(true, 'should support the this-arg argument'); // todo

    @include assert-equal(_take-while($maps, 'b'), _slice($maps, 0, 2),
      'should work with a _pluck style predicate');

    @include assert-equal(_take-while($maps, ('b': 2)), _slice($maps, 0, 1),
      'should work with a _where style predicate');

    @include assert-equal(_($list, take-while test-take-while-1, value), 1 2,
      'should return expected value when chaining');
  }
}

@function test-flatten-1($args...) {
  @return $args;
}
@include test-module('Sassdash') {
  $args: test-flatten-1(1, 2, 3);

  @include test('flatten methods') {
    $list: ((('a',),), (('b',),));

    @include assert-equal(_flatten($list), (('a',), ('b',)),
      'should perform a shallow flatten');

    $expected: ('a', 'b');

    @include assert-equal(_flatten($list, true), $expected,
      'should work with isDeep');

    @include assert-equal(_flatten-deep($list), $expected,
      'should work with isDeep');

    $list: ($args, ($args,));
    $expected: (1, 2, 3, $args);

    @include assert-equal(_flatten($list), $expected,
      'should flatten arglists');

    $expected: (1, 2, 3, 1, 2, 3);

    @include assert-equal(_flatten($list, true), $expected,
      'should flatten arglists');

    @include assert-equal(_flatten-deep($list), $expected,
      'should flatten arglists');

    $list: (((('a',),),), ((('b',),),));

    @include assert-equal(_map($list, _flatten), ((('a',),), (('b',),)),
      'should work as an iteratee for _map');

    @include assert-equal(_map($list, _flatten-deep), (('a',), ('b',)),
      'should work as an iteratee for _map');
    
    $list: ((), ((),), ((), (((),),),));
    $expected: ((), (), (((),),));

    @include assert-equal(_flatten($list), $expected,
      'should work with empty lists');

    @include assert-equal(_flatten($list, true), $test-empty-list,
      'should work with empty lists');

    @include assert-equal(_flatten-deep($list), $test-empty-list,
      'should work with empty lists');

    $list: (1, (2,), (3, (4,)));
    $expected: (1, 2, 3, (4,));

    @include assert-equal(_flatten($list), $expected,
      'should support flattening of nested lists');

    $expected: (1, 2, 3, 4);

    @include assert-equal(_flatten($list, true), $expected,
      'should support flattening of nested lists');

    @include assert-equal(_flatten-deep($list), $expected,
      'should support flattening of nested lists');

    $expected: ();

    @include assert-equal(_flatten(('a': 1)), $expected,
      'should return empty list for non list-like objects');

    @include assert-equal(_flatten(('a': 1), true), $expected,
      'should return empty list for non list-like objects');

    @include assert-equal(_flatten-deep(('a': 1)), $expected,
      'should return empty list for non list-like objects');
  }
}

@include test-module('Sassdash') {
  @include test('_for-each') {
    @include assert-equal(_each(1 2 3, test-square), _for-each(1 2 3, test-square),
      'should be aliased');
  }

  @include test('_for-each-right') {
    @include assert-equal(_each-right(1 2 3, test-square), _for-each-right(1 2 3, test-square),
      'should be aliased');
  }
}

// @include test-module('Sassdash iteration methods') {
//   $methods: (
//     'count-by',
//     'every',
//     'filter',
//     'find',
//     'find-index',
//     'find-key',
//     'find-last',
//     'find-last-index',
//     'find-last-key',
//     'for-each-right',
//     'for-in',
//     'for-in-right',
//     'for-own',
//     'for-own-right',
//     'group-by',
//     'index-by',
//     'map',
//     'max',
//     'min',
//     'partition',
//     'reject',
//     'some'
//   );

//   $array-methods: (
//     'find-index',
//     'find-last-index'
//   );

//   $collection-methods: (
//     'count-by',
//     'every',
//     'filter',
//     'find',
//     'find-last',
//     'for-each',
//     'for-each-right',
//     'group-by',
//     'index-by',
//     'map',
//     'max',
//     'min',
//     'partition',
//     'reduce',
//     'reduce-right',
//     'reject',
//     'some'
//   );

//   $for-in-methods: (
//     'for-in',
//     'for-in-right'
//   );

//   $iteration-methods: (
//     'for-each',
//     'for-each-right',
//     'for-in',
//     'for-in-right',
//     'for-own',
//     'for-own-right'
//   );

//   $map-methods: (
//     'find-key',
//     'find-last-key',
//     'for-in',
//     'for-in-right',
//     'for-own',
//     'for-own-right'
//   );

//   $right-methods: (
//     'find-last',
//     'find-last-index',
//     'find-last-key',
//     'for-each-right',
//     'for-in-right',
//     'for-own-right'
//   );

//   $unwrapped-methods: (
//     'every',
//     'find',
//     'find-index',
//     'find-key',
//     'find-last',
//     'find-last-index',
//     'find-last-key',
//     'max',
//     'min',
//     'some'
//   );
// }

@include test-module('Sassdash') {
  @include test('map assignments') {  
    // TODO: add 'merge'
    @each $method-name in 'assign', 'defaults' {
      $func: unquote('_#{$method-name}');

      @each $value in $test-falsey {
        $actual: _call($func, null, $value);
        $expected: $value;

        @include assert-equal($actual, $expected,
          '#{$func} should pass thru falsey map values');
      }

      $list: (('b': 2), ('c': 3));
      $actual: _reduce($list, $func, ('a': 1));
      $expected: ('a': 1, 'b': 2, 'c': 3);

      @include assert-equal($actual, $expected,
        '#{$func} should work as an iteratee for _reduce');
    }
  }
}

// @include test-module('Sassdash') {
//   @include test('_merge') {
//     $names: (
//       'characters': (
//         ('name': 'barney'),
//         ('name': 'fred')
//       )
//     );

//     $ages: (
//       'characters': (
//         ('age': 36),
//         ('age': 40)
//       )
//     );

//     $heights: (
//       'characters': (
//         ('height': '5ft4'),
//         ('height': '5ft5')
//       )
//     );

//     $expected: (
//       'characters': (
//         ('name': 'barney', 'age': 36, 'height': '5ft4'),
//         ('name': 'fred', 'age': 40, 'height': '5ft5')
//       )
//     );

//     @include assert-equal(_merge($names, $ages, $heights), $expected
//       'should merge source into the destination object');
//   }
// }

@include test-module('Sassdash') {
  @include test('_min') {
    @include assert-equal(_min(1 2 3), 1,
      'should return the smallest value from a collection');

    @include assert-equal(_min(()), const-get('POSITIVE_INFINITY'),
      'should return Infinity for empty collections');

    @include assert-equal(_min(('a' 'b') ('a': 'a', 'b': 'b')), const-get('POSITIVE_INFINITY'),
      'should return Infinity for non-numeric collection items');
  }
}

@function test-maxmin-1($num, $args...) {
  @return -$num;
}
@include test-module('Sassdash') {
  @include test('_max and _min') {
    @each $method-name in 'max', 'min' {
      $list: 1 2 3;
      $func: unquote('_#{$method-name}');
      $is-max: $method-name == 'max';

      @include assert-equal(_call($func, null, $list, test-maxmin-1), if($is-max, 1, 3),
        'should work with an iteratee argument');

      $maps: (('a': 2), ('a': 3), ('a': 1));
      $actual: _call($func, null, $maps, 'a');

      @include assert-equal($actual, nth($maps, if($is-max, 2, 3)),
        'should work with _pluck style iteratee');

      $actual: _call($func, null, ('a': 1, 'b': 2, 'c': 3));

      @include assert-equal($actual, if($is-max, 3, 1),
        'should iterate a map');

      @include assert-equal(_call($func, null, 'abc'), if($is-max, 'c', 'a'),
        'should iterate a string');

      $list: (2 3 1, 5 6 4, 8 9 7);
      $actual: _map($list, $func);

      @include assert-equal($actual, if($is-max, 3 6 9, 1 4 7),
        '#{$func} should work as an iteratee for _map');

      @include assert-equal(_map('abc', $func), 'a' 'b' 'c',
        '#{$func} should work as an iteratee for _map');

      @include assert-equal(_((40,), $method-name), 40,
        'should work when chaining on a list with only one value');
    }
  }
}

@include test-module('Sassdash') {
  @include test('_negate') {
    $negate: _negate(test-is-even);

    @include assert-equal(_call($negate, null, 1), true,
      'should create a function that negates the result of func');

    @include assert-equal(_call($negate, null, 2), false,
      'should create a function that negates the result of func');
  }
}

@include test-module('Sassdash') {
  @include test('_noop') {
    @include assert-equal(_noop(1, 2, 3), null,
      'should return null');
  }
}

@include test-module('Sassdash') {
  @include test('_omit') {
    $map: ('a': 1, 'b': 2, 'c': 3);
    $expected: ('b': 2);

    @include assert-equal(_omit($map, 'a'), ('b': 2, 'c': 3),
      'should create a map with omitted properties');

    @include assert-equal(_omit($map, 'a', 'c'), $expected,
      'should create a map with omitted properties');

    @include assert-equal(_omit($map, 'a' 'c'), $expected,
      'should support picking a list of properties');

    @include assert-equal(_omit($map, ('a',), 'c'), $expected,
      'should support picking a list of properties and individual properties');

    @include assert-equal(_omit(null, 'test'), (),
      'should return an empty map when map is null');

    $args: test-args('a', 'c');

    @include assert-equal(_omit($map, $args), $expected,
      'should work with arglists as secondary arguments');

    @include assert-equal(_omit(1 2 3, 1, 3), (2: 2),
      'should work with a list map argument');
    
    // TODO: investigate failing test
    // @include assert-equal(_omit($map, test-is-even), ('a': 1, 'c': 3),
    //   'should work with a predicate argument');
  }
}

@include test-module('Sassdash') {
  @include test('_once') {
    $once: _once(test-square);
    $actual: _call($once, null, 2);

    @include assert-equal($actual, 4,
      'should invoke func once');

    $actual: _call($once, null, 2);

    @include assert-equal($actual, null,
      'should invoke func once');
  }
}

@include test-module('Sassdash') {
  @include test('_pad') {
    @include assert-equal(_pad('abc', 9), '   abc   ',
      'should pad a string to a given length');

    @include assert-equal(_pad('abc', 8), '  abc   ',
      'should truncate pad characters to fit the pad length');

    @include assert-equal(_pad('abc', 8, '_-'), '_-abc_-_',
      'should truncate pad characters to fit the pad length');

    @include assert-equal(_pad(123, 9), '   123   ',
      'should coerce to a string');
  }

  @include test('_pad-left') {
    @include assert-equal(_pad-left('abc', 9), '      abc',
      'should pad a string to a given length');

    @include assert-equal(_pad-left('abc', 6, '_-'), '_-_abc',
      'should truncate pad characters to fit the pad length');

    @include assert-equal(_pad-left(123, 4), ' 123',
      'should coerce to a string');
  }

  @include test('_pad-right') {
    @include assert-equal(_pad-right('abc', 9), 'abc      ',
      'should pad a string to a given length');

    @include assert-equal(_pad-right('abc', 6, '_-'), 'abc_-_',
      'should truncate pad characters to fit the pad length');

    @include assert-equal(_pad-right(123, 4), '123 ',
      'should coerce to a string');
  }

  @include test('_pad methods') {
    @each $method-name in 'pad', 'pad-left', 'pad-right' {
      $func: unquote('_#{$method-name}');
      $is-pad-left: $method-name == 'pad-left';

      @include assert-equal(_call($func, null, 'abc', 2), 'abc',
        'should not pad if string is >= length');

      @include assert-equal(_call($func, null, 'abc', 3), 'abc',
        'should not pad if string is >= length');

      @include assert-equal(_call($func, null, 'abc', 0), 'abc',
        'should treat negative length as 0');

      @include assert-equal(_call($func, null, 'abc', -3), 'abc',
        'should treat negative length as 0');

      @include assert-equal(_call($func, null, null, 0, null), '',
        'should return an empty string when provided null or empty string and chars');

      @include assert-equal(_call($func, null, null, 0, '_-'), '',
        'should return an empty string when provided null or empty string and chars');

      @include assert-equal(_call($func, null, '', 0, null), '',
        'should return an empty string when provided null or empty string and chars');

      @include assert-equal(_call($func, null, '', 0, '_-'), '',
        'should return an empty string when provided null or empty string and chars');

      @include assert-equal(_call($func, null, 'abc', 6, null), 'abc',
        'should work with null or empty string for chars');

      @include assert-equal(_call($func, null, 'abc', 6, ''), 'abc',
        'should work with null or empty string for chars');
    }
  }
}

@include test-module('Sassdash') {
  @include test('_pairs') {
    $map: ('a': 1, 'b': 2);

    @include assert-equal(_pairs($map), (('a', 1), ('b', 2)),
      'should create a 2d list of key-value pairs');
  }
}

// todo _parseint

@function test-partial-1($a, $b) {
  @return ($a, $b);
}
@function test-partial-2($args...) {
  @return length($args);
}
@include test-module('Sassdash') {
  @include test('_partial methods') {
    @each $method-name in 'partial', 'partial-right' {
      $func: unquote('_#{$method-name}');
      $is-partial: $method-name == 'partial';

      $par: _call($func, null, _identity, 'a');

      @include assert-equal(_call($par), 'a',
        '#{$func} partially applies arguments');

      $expected: ('a', 'b');
      $par: _call($func, null, test-partial-1, 'a');

      @include assert-equal(_call($par, null, 'b'), if($is-partial, $expected, __list-reverse($expected)),
        '#{$func} creates a function that can be invoked with additional arguments');

      $par: _call($func, null, test-partial-2);

      @include assert-equal(_call($par), 0,
        '#{$func} works when there are no partially applied arguments and the created function is invoked without additional arguments');

      $par: _call($func, null, _identity);

      @include assert-equal(_call($par, null, 'a'), 'a',
        '#{$func} works when there are no partially applied arguments and the created function is invoked with additional arguments');
    }
  }
}

@include test-module('Sassdash') {
  @include test('_partition') {
    $list: 1 0 1;

    @include assert-equal(_partition((), _identity), ((), ()),
      'should return two groups of elements');

    @include assert-equal(_partition($list, _constant(true)), ($list, ()),
      'should return two groups of elements');

    @include assert-equal(_partition($list, _constant(false)), ((), $list),
      'should return two groups of elements');

    $expected: (1 1), (0,);

    @include assert-equal(_partition($list, null), $expected,
      'should use _identity when predicate is nullish');

    @include assert-equal(_partition($list), $expected,
      'should use _identity when predicate is nullish');

    // todo: should support the this-arg argument

    $maps: (('a': 1), ('a': 1), ('b': 2));
    $expected: _slice($maps, 0, 2), _slice($maps, 2);

    @include assert-equal(_partition($maps, 'a'), $expected,
      'should work with a _pluck style predicate');

    $list: (1 0, 0 1, 1 0);
    $expected: ((1 0, 1 0), (0 1,));

    @include assert-equal(_partition($list, 1), $expected,
      'should work with a number for predicate');

    $map: ('a': 1.1, 'b': 0.2, 'c': 1.3);

    @include assert-equal(_partition($map, test-floor), ((1.1, 1.3), (0.2,)),
      'should work with map for collection');
  }
}

@include test-module('Sassdash') {
  $map: ('a': 1, 'b': 2, 'c': 3);
  $expected: ('a': 1, 'c': 3);

  @include test('_pick') {  
    @include assert-equal(_pick($map, 'a'), ('a': 1),
      'should create a map of picked properties');

    @include assert-equal(_pick($map, 'a' 'c'), $expected,
      'should support picking a list of properties');

    @include assert-equal(_pick($map, ('a',), 'c'), $expected,
      'should support picking a list of properties and individual properties');

    @include assert-equal(_pick(null, 'something'), (),
      'should return an empty map when map is null');

    $args: test-args('a', 'c');
    @include assert-equal(_pick($map, $args), $expected,
      'should work with arglist as secondary arguments');

    @include assert-equal(_pick(1 2 3, 2), (2: 2),
      'should work with a list map argument');

    @include assert-equal(_pick($map, test-is-even), ('b': 2),
      'should work with a predicate argument');
  }
}

@include test-module('Sassdash') {
  @include test('_pluck') {
    $maps: (
      ('name': 'barney', 'age': 36),
      ('name': 'fred', 'age': 40)
    );

    @include assert-equal(_pluck($maps, 'name'), ('barney', 'fred'),
      'should return a list of property values from each element of a collection');

    $map: ('a': (1: 'one'), 'b': (1: 'two'), 'c': (1: 'three'));

    @include assert-equal(_pluck($map, 1), ('one' 'two' 'three'),
      'should work with a map for collection');

    $list: (('a': 1),);

    @include assert-equal(_pluck($list, 'b'), (null,),
      'should return null for undefined properties');

    $maps: (('a': 1), null, false, ('a': 4));

    @include assert-equal(_pluck($maps, 'a'), (1 null null 4),
      'should work with nullish elements');

    $list: (('a': 1), null, ('a': 3), ('a': 4));
    $actual: _($list, pluck 'a', value);

    @include assert-equal($actual, 1 null 3 4,
      'should work in a lazy chain sequence');

    @include assert-equal(_($list, filter _identity, pluck 'a', value), 1 3 4,
      'should work in a lazy chain sequence');
  }
}

@include test-module('Sassdash') {
  @include test('_property') {
    $map: ('a': 1, 'b': 2);
    $prop: _property('a');

    @include assert-equal(_call($prop, null, $map), 1,
      'should create a function that plucks a property value of a given map');

    $prop: _property('b');

    @include assert-equal(_call($prop, null, $map), 2,
      'should create a function that plucks a property value of a given map');

    $prop: _property(2);

    @include assert-equal(_call($prop, null, 10 20 30), 20,
      'should work with non-string prop arguments');

    $prop: _property('a');

    @include assert-equal(_call($prop, null, null), null,
      'should work when map is nullish');
  }
}

@include test-module('Sassdash') {
  @include test('_pull') {
    $list: 1 200 3;

    @include assert-equal(_pull($list, 1, 3), (200,),
      'should return the modified list');
  }
}

@include test-module('Sassdash') {
  $list: null null null null null null null null null null null null null null null null null null null null;

  @include test('_rand') {
    $actual: _map($list, _rand);

    @include assert-equal(sort(_uniq($actual)), (0, 1),
      'should return 0 or 1 when arguments are not provided');

    $min: 5;
    $max: 10;

    $is-within-range: true;

    @each $item in $list {
      $result: _rand($min, $max);
      $is-within-range: $result >= $min and $result <= $max;
    }

    @include assert-equal($is-within-range, true,
      'should support a min and max argument');

    $min: 0;
    $max: 5;

    $is-within-range: true;

    @each $item in $list {
      $result: _rand($max);
      $is-within-range: $result >= $min and $result <= $max;
    }

    @include assert-equal($is-within-range, true,
      'should support not providing a max argument');

    @include assert-equal(_rand('1', '1'), 1,
      'should coerce arguments to numbers');

    $min: 1.5;
    $max: 1.6;
    $actual: _rand($min, $max);

    @include assert-equal($actual % 1 > 0, true,
      'should support floats');

    @include assert-equal($actual >= $min and $actual <= $max, true,
      'should support floats');

    $actual: _rand(true);
    $actual: if($actual % 1 == 0, _rand(true), $actual);

    @include assert-equal($actual % 1 > 0 and $actual >= 0 and $actual <= 1, true,
      'should support providing a floating argument');

    $actual: _rand(2, true);
    $actual: if($actual % 1 == 0, _rand(2, true), $actual);

    @include assert-equal($actual % 1 > 0 and $actual >= 0 and $actual <= 2, true,
      'should support providing a floating argument');

    $actual: _rand(2, 4, true);
    $actual: if($actual % 1 == 0, _rand(2, 4, true), $actual);

    @include assert-equal($actual % 1 > 0 and $actual >= 2 and $actual <= 4, true,
      'should support providing a floating argument');

    $list: 1 2 3 4 5 6 7 8 9 10;
    $randoms: _map($list, _rand);
    $result: true;

    @each $random-index, $random-value in zip($list, $randoms) {
      $result: $result and $random-value >= 0 and $random-value <= $random-index and $random-value % 1 == 0;
    }

    @include assert-equal($result, true,
      'should work as an iteratee for _map');
  }
}

@include test-module('Sassdash') {
  @include test('_range') {
    @include assert-equal(_range(4), 0 1 2 3,
      'should work with a single end argument');

    @include assert-equal(_range(1, 5), 1 2 3 4,
      'should work with start and end arguments');

    @include assert-equal(_range(0, 20, 5), 0 5 10 15,
      'should work with start, end, and step arguments');

    @include assert-equal(_range(1, 4, 0), 1 1 1,
      'should support a step of 0');

    @include assert-equal(_range(1, 5, 20), (1,),
      'should work with a step larger than end');

    @include assert-equal(_range(0, -4, -1), 0 -1 -2 -3,
      'should work with a negative step argument');

    @include assert-equal(_range(21, 10, -3), 21 18 15 12,
      'should work with a negative step argument');

    @each $value in $test-falsey {
      @include assert-equal(_range($value), (),
        'should treat falsey arguments as 0');
    }

    $actual: _map(1 2 3, _range);
    $expected: (0,), (0 1), (0 1 2);

    @include assert-equal($actual, $expected,
      'should work as an iteratee for _map');
  }
}

@function test-reduce-1($a, $b, $args...) {
  @return $a + $b + to-upper-case($b);
}
@include test-module('Sassdash') {
  $list: 1 2 3;

  @include test('_reduce') {  
    @include assert-equal(_reduce($list), 1,
      'should use the first element of a collection as the default accumulator');

    @include assert-equal(_reduce($list, test-add), 6,
      'should reduce a collection given an iterator');

    @include assert-equal(_reduce('abc', test-reduce-1, ''), 'aAbBcC',
      'should work with a string literal for collection');

    @include assert-equal(_foldl($list, test-add), _reduce($list, test-add),
      'should be aliased');

    @include assert-equal(_inject($list, test-add), _reduce($list, test-add),
      'should be aliased');
  }
}

@include test-module('Sassdash') {
  $list: 1 2 3;

  @include test('_reduce-right') {  
    @include assert-equal(_reduce-right($list), 3,
      'should use the last element of a collection as the default accumulator');

    @include assert-equal(_reduce-right($list, test-add), 6,
      'should reduce a collection given an iterator');

    @include assert-equal(_reduce-right('abc', test-reduce-1, ''), 'cCbBaA',
      'should work with a string literal for collection');

    @include assert-equal(_foldr($list, test-add), _reduce-right($list, test-add),
      'should be aliased');
  }
}

@include test-module('Sassdash') {
  $list: 1 2 3;

  @include test('_reduce methods') {  
    @each $method-name in 'reduce', 'reduce-right' {
      $func: unquote('_#{$method-name}');
      $is-reduce: $method-name == 'reduce';

      @include assert-equal(
        _call($func, null, 'a' 'b' 'c', test-add, ''),
        if($is-reduce, 'abc', 'cba'),
        '#{$func} should reduce a collection to a single value');

      @include assert-equal(
        _call($func, null, (), _noop),
        null,
        '#{$func} should support empty collections without an initial accumulator value');

      @include assert-equal(
        _call($func, null, (), _noop, 'x'),
        'x',
        '#{$func} should support empty collections with an initial accumulator value');
    }
  }
}

@include test-module('Sassdash') {
  @include test('_reject') {
    @include assert-equal(_reject(1 2 3, is-even), 1 3,
      'should return elements the predicate returns falsey for');
  }
}

@function test-filter-methods-1($value, $args...) {
  @return $value > 3;
}
@include test-module('Sassdash') {
  @include test('filter methods') {
    @each $method-name in 'filter', 'reject' {
      $func: unquote('_#{$method-name}');
      $is-filter: $method-name == 'filter';

      $maps: (('a': 0), ('a': 1));

      @include assert-equal(
        _call($func, null, $maps, 'a'),
        (nth($maps, if($is-filter, 2, 1)),),
        '#{$func} should work with a _pluck style predicate');

      @include assert-equal(
        _call($func, null, $maps, nth($maps, 2)),
        (nth($maps, if($is-filter, 2, 1)),),
        '#{$func} should work with a _where style predicate');

      $list: 1 2 3;
      $map: ('a': 1, 'b': 2, 'c': 3);

      $actual: _($list, map test-square, $method-name test-filter-methods-1, value);

      @include assert-equal(
        $actual,
        if($is-filter, 4 9, (1,)),
        '#{$func} should work in a lazy chain sequence');

      @actual: _($map, map-values test-square, $method-name test-filter-methods-1, value);

      @include assert-equal(
        $actual,
        if($is-filter, 4 9, (1,)),
        '#{$func} should work in a lazy chain sequence');
    }
  }
}

@include test-module('Sassdash') {
  @include test('_repeat') {
    @include assert-equal(_repeat('*', 3), '***',
      'should repeat a string n times');

    @include assert-equal(_repeat('abc', 3), 'abcabcabc',
      'should repeat a string n times');

    @include assert-equal(_repeat('abc', 0), '',
      'should return an empty string for negative n or n of 0');

    @include assert-equal(_repeat('abc', -2), '',
      'should return an empty string for negative n or n of 0');

    @include assert-equal(_repeat('abc'), '',
      'should coerce n to a number');

    @include assert-equal(_repeat('abc', '2'), 'abcabc',
      'should coerce n to a number');

    @include assert-equal(_repeat(123, '2'), '123123',
      'should coerce string to a string');
  }
}

@function test-result-1() {
  @return this('a');
}
@include test-module('Sassdash') {
  @include test('_result') {
    $map: (
      'a': 1,
      'b': null,
      'c': test-result-1
    );

    @include assert-equal(_result($map, 'a'), 1,
      'should resolve property values');

    @include assert-equal(_result($map, 'b'), null,
      'should resolve property values');

    @include assert-equal(_result($map, 'c'), 1,
      'should resolve property values');

    @include assert-equal(_result($map, 'd'), null,
      'should resolve property values');

    @include assert-equal(_result(null, 'a'), null,
      'should return null when map is nullish');

    @include assert-equal(_result($map, 'd', 42), 42,
      'should return the specified default value for undefined properties');

    @include assert-equal(_result($map, 'd', get($map, 'c')), 1,
      'should execute default function values');
  }
}

@include test-module('Sassdash') {
  @include test('_rest') {
    $list: 1 2 3;

    @each $value in $test-falsey {
      @include assert-equal(_rest($value), (),
        'should accept a falsey list argument');
    }

    @include assert-equal(_rest($list), 2 3,
      'should exclude the first element');

    @include assert-equal(_rest(()), (),
      'should return an empty list when querying empty lists');

    $list-list: (1 2 3, 4 5 6, 7 8 9);
    $actual: _map($list-list, _rest);

    @include assert-equal($actual, (2 3, 5 6, 8 9),
      'should work as an iteratee for _map');

    @include assert-equal(_($list, rest, filter test-is-even, value), (2,),
      'should work in a lazy chain sequence');

    @include assert-equal(_tail($list), _rest($list),
      'should be aliased');
  }
}

@include test-module('Sassdash') {
  @include test('_sample') {
    $list: 1 2 3;

    $actual: _sample($list);
    @include assert-equal(_includes($list, $actual), true,
      'should return a random element');

    $actual: _sample($list, 2);

    @include assert-equal(_includes($list, nth($actual, 1)) and _includes($list, nth($actual, 2)) and length($actual) == 2, true,
      'should return two random elements');

    $actual: _sample($list, length($list));

    @include assert-equal(sort($actual), $list,
      'should contain elements of the collection');

    @each $value in $test-falsey {
      @include assert-equal(_sample((1,), $value), if($value == null, 1, ()),
        'should treat falsey n values, except null, as 0');
    }

    @each $value in 0, -1, -9999 {
      @include assert-equal(_sample($list, $value), (),
        'should return an empty list when n < 1 or NaN');
    }

    @each $value in 3, 4, pow(2, 32), 9999 {
      @include assert-equal(sort(_sample($list, $value)), $list,
        'should return all elements when n >= list length');
    }

    @include assert-equal(_sample(()), null,
      'should return null when sampling an empty list');

    $values: (1 2 3, 4 5 6, 7 8 9);
    $actual: _map($values, _sample);

    @include assert-equal(_includes(nth($values, 1), nth($actual, 1)) and _includes(nth($values, 2), nth($actual, 2)) and _includes(nth($values, 3), nth($actual, 3)), true,
      'should work as an iteratee for _map');

    $values: ('abc', 'def', 'ghi');
    $actual: _map($values, _sample);

    @include assert-equal(_includes($values, nth($actual, 1)) and _includes($values, nth($actual, 2)) and _includes($values, nth($actual, 3)), true,
      'should work as an iteratee for _map');

    $actual: _sample('abc', 2);

    @include assert-equal(length($actual) == 2 and nth($actual, 1) != nth($actual, 2) and _includes('abc', nth($actual, 1)), true,
      'should work with a string literal for collection');
  }
}

@function test-shuffle-1($args...) {
  @return _shuffle(1 2);
}
@include test-module('Sassdash') {
  @include test('_shuffle') {
    $list: 1 2 3 4 5;
    $map: ('a': 1, 'b': 2, 'c': 3);

    @include assert-equal(_shuffle($list) != $list, true,
      'should return a new list');

    @include assert-equal(sort(_shuffle($list)), $list,
      'should contain the same elements after a collection is shuffled');

    @include assert-equal(length(_shuffle($map)), length($map),
      'should contain the same elements after a collection is shuffled');

    $actual: _times(10, test-shuffle-1);

    @include assert-equal(_sort-by(_uniq($actual), 1), (1 2, 2 1),
      'should shuffle small collections');
  }
}

@include test-module('Sassdash') {
  @include test('_size') {
    $list: 1 2 3;

    @include assert-equal(_size(('one': 1, 'two': 2, 'three': 3)), 3,
      'should return the number of own enumerable properties of a map');

    @include assert-equal(_size($list), 3,
      'should return the length of a list');

    @each $value in $test-falsey {
      @include assert-equal(_size($value), 0,
        'should accept a falsey map arg');
    }

    $args: test-args(1, 2, 3);

    @include assert-equal(_size($args), 3,
      'should work with arglist object');

    @include assert-equal(_size('abc'), 3,
      'should work with a string for collection');
  }
}

@include test-module('Sassdash') {
  @include test('_slice') {
    $list: 1 2 3;

    @include assert-equal(_slice($list, 1), 2 3,
      'should work with a positive start');

    @each $value in 3, 4, pow(2, 32), 9999 {
      @include assert-equal(_slice($list, $value), (),
        'should work with a start >= list length');
    }

    @each $value in $test-falsey {
      @include assert-equal(_slice($list, $value), $list,
        'should treat falsey start values as 0');
    }

    @include assert-equal(_slice($list, -1), (3,),
      'should work with a negative start');

    @each $value in -3, -4, -9999 {
      @include assert-equal(_slice($list, $value), $list,
        'should work with a negative start <= negative list length');
    }

    @each $value in 2, 3 {
      @include assert-equal(_slice($list, $value, 2), (),
        'should work with start >= end');
    }

    @include assert-equal(_slice($list, 0, 1), (1,),
      'should work with positive end');

    @each $value in 3, 4, pow(2, 32), 9999 {
      @include assert-equal(_slice($list, 0, $value), $list,
        'should work with an end >= list length');
    }

    @each $value in $test-falsey {
      @include assert-equal(_slice($list, 0, $value), (),
        'should treat falsey end values as 0');
    }

    @include assert-equal(_slice($list, 0, -1), 1 2,
      'should work with a negative end');

    @each $value in -3, -4, -9999 {
      @include assert-equal(_slice($list, 0, $value), (),
        'should work with a negative end <= negative list length');
    }

    $actual: (
      _slice($list, 0.1, 1.1),
      _slice($list, '0', 1),
      _slice($list, 0, '1'),
      _slice($list, '1'),
    );

    $expected: ((1,), (1,), (1,), (2 3));

    @include assert-equal($actual, $expected,
      'should coerce start and end to integers');

    $list: ((1,), (2 3));
    $actual: _map($list, _slice);

    @include assert-equal($actual, $list,
      'should work as iteratee for map');
  }
}

@include test-module('Sassdash') {
  @include test('_some') {
    @include assert-equal(_some((), _identity), false,
      'should return false for empty collections');

    @include assert-equal(_some(false 1 '', _identity), true,
      'should return true if predicate returns truthy for any element in the collection');

    @include assert-equal(_some(null 'x' 0, _identity), true,
      'should return true if predicate returns truthy for any element in the collection');

    @include assert-equal(_some(false false false, _identity), false,
      'should return false if predicate returns falsey for all elements in the collection');

    @include assert-equal(_some(null 0 '', _identity), false,
      'should return false if predicate returns falsey for all elements in the collection');

    @include assert-equal(_some(null true null, _identity), true,
      'should return true as soon as predicate returns truthy');

    $maps: (('a': 0, 'b': 0), ('a': 0, 'b': 1));

    @include assert-equal(_some($maps, 'a'), false,
      'should work with a _pluck style predicate');

    @include assert-equal(_some($maps, 'b'), true,
      'should work with a _pluck style predicate');

    @include assert-equal(_some($maps, ('a': 0)), true,
      'should work with a _where style predicate');

    @include assert-equal(_some($maps, ('b': 2)), false,
      'should work with a _where style predicate');

    @include assert-equal(_some(0 0), false,
      'should use _identity when predicate is nullish');

    @include assert-equal(_some(0 0, null), false,
      'should use _identity when predicate is nullish');

    @include assert-equal(_some(0 1), true,
      'should use _identity when predicate is nullish');

    @include assert-equal(_some(0 1, null), true,
      'should use _identity when predicate is nullish');

    @include assert-equal(_any(0 1), _some(0 1),
      'should be aliased');
  }
}

@function test-sort-by-1($a, $b, $c) {
  @return ('a': $a, 'b': $b, 'c': $c);
}
@function test-sort-by-2($map, $args...) {
  @return get($map, 'b');
}
@function test-sort-by-3($map, $args...) {
  @return get($map, 'a');
}
@include test-module('Sassdash') {
  @include test('_sort-by') {
    $maps: (
      ( 'a': 'x', 'b': 3 ),
      ( 'a': 'y', 'b': 4 ),
      ( 'a': 'x', 'b': 1 ),
      ( 'a': 'y', 'b': 2 )
    );

    $stable-order: (
      test-sort-by-1(1, 1, 1), test-sort-by-1(1, 2, 1),
      test-sort-by-1(1, 1, 1), test-sort-by-1(1, 2, 1),
      test-sort-by-1(1, 3, 1), test-sort-by-1(1, 4, 1),
      test-sort-by-1(1, 5, 1), test-sort-by-1(1, 6, 1),
      test-sort-by-1(2, 1, 2), test-sort-by-1(2, 2, 2),
      test-sort-by-1(2, 3, 2), test-sort-by-1(2, 4, 2),
      test-sort-by-1(2, 5, 2), test-sort-by-1(2, 6, 2),
      test-sort-by-1(3, 1, 1), test-sort-by-1(3, 2, 1),
      test-sort-by-1(3, 3, 1), test-sort-by-1(3, 4, 1),
      test-sort-by-1(3, 5, 1), test-sort-by-1(3, 6, 1)
    );

    $actual: _pluck(_sort-by($maps, test-sort-by-2), 'b');

    @include assert-equal($actual, 1 2 3 4,
      'should sort in ascending order');

    $actual: _sort-by($stable-order, test-sort-by-3);

    @include assert-equal($actual, $stable-order,
      'should perform a stable sort');

    $list: 3 2 1;

    @include assert-equal(_sort-by($list), 1 2 3,
      'should use _identity when iteratee is nullish');

    @include assert-equal(_sort-by($list, null), 1 2 3,
      'should use _identity when iteratee is nullish');

    $list: null 4 1 null 3 null 2;

    // @include assert-equal(_sort-by($list), 1 2 3 4 null null null,
    //   'should move null values to the end');

    @include assert-equal(_pluck(_sort-by($maps, 'b'), 'b'), (1 2 3 4),
      'should work with a _pluck style iteratee');

    @include assert-equal(_sort-by(('a': 3, 'b': 1, 'c': 2)), 1 2 3,
      'should work with a map for collection');

    @include assert-equal(_sort-by(1), (),
      'should treat number values for collection as empty');

    $actual: _map((2 1 3, 3 2 1), _sort-by);

    @include assert-equal($actual, (1 2 3, 1 2 3),
      'should work as an iteratee for _map');

    // @include assert-equal(
    //   _sort-by-all($maps, 'a' 'b'),
    //   nth($maps, 3) nth($maps, 1) nth($maps, 4) nth($maps, 2),
    //   '_sort-by-all should sort multiple properties in ascending order');

    @include assert-equal(_sort-by-all($stable-order, 'a' 'c'), $stable-order,
      '_sort-by-all should perform a stable sort');
  }
}

// @include test-module('Sassdash') {
//   @include test('_sorted-index') {
//      // todo
//   }
// }

@include test-module('Sassdash') {
  @include test('_starts-with') {
    $string: 'abc';

    @include assert-equal(_starts-with($string, 'a'), true,
      'should return true if a string starts with target');

    @include assert-equal(_starts-with($string, 'b'), false,
      'should return false if a string does not start with target');

    @include assert-equal(_starts-with($string, 'b', 2), true,
      'should work with a position argument');

    @include assert-equal(_starts-with($string, 'a', 4), false,
      'should work with position >= string length');

    @each $value in $test-falsey {
      @include assert-equal(_starts-with($string, 'a', $value), true,
        'should treat falsey position values as 1');
    }

    @include assert-equal(_starts-with($string, 'a', -1), true,
      'should treat a negative position as 1');

    @each $position in -9999, -3, -1, 0, 1, 2, 3, 5 {    
      @include assert-equal(_starts-with($string, '', $position), true,
        'should return true when target is an empty string regardless of position');
    }
  }
}

@include test-module('Sassdash') {
  @include test('_trunc') {
    $string: 'hi-diddly-ho there, neighborino';

    @include assert-equal(_trunc($string), 'hi-diddly-ho there, neighbo...',
      'should truncate to a length of 30 by default');

    @include assert-equal(_trunc($string, str-length($string)), $string,
      'should not truncate if string is <= length');

    @include assert-equal(_trunc($string, str-length($string) + 2), $string,
      'should not truncate if string is <= length');

    @include assert-equal(_trunc($string, 24), 'hi-diddly-ho there, n...',
      'should truncate string the given length');

    @include assert-equal(_trunc($string, ('omission': ' [...]')), 'hi-diddly-ho there, neig [...]',
      'should support an omission option');

    @include assert-equal(_trunc($string, $omission: ' [...]'), 'hi-diddly-ho there, neig [...]',
      'should support a named param omission option');

    @include assert-equal(_trunc($string, ('length': 4)), 'h...',
      'should support a length option');

    @include assert-equal(_trunc($string, $length: 4), 'h...',
      'should support a named param length option');

    @include assert-equal(_trunc($string, ('length': 24, 'separator': ' ')), 'hi-diddly-ho there,...',
      'should support a separator option');

    @include assert-equal(_trunc($string, $length: 24, $separator: ' '), 'hi-diddly-ho there,...',
      'should support a named param separator option');

    @include assert-equal(_trunc($string, 0), '...',
      'should handle zero length correctly');

    @include assert-equal(_trunc($string, -3), '...',
      'should treat negative length as 0');

    @include assert-equal(_trunc($string, '4'), 'h...',
      'should coerce length to an integer');

    @include assert-equal(_trunc(12345, '4'), '1...',
      'should coerce string to a string');

    $truncated: 'hi-diddly-ho there, neighbo...';

    @include assert-equal(_map($string $string $string, _trunc), $truncated $truncated $truncated,
      'should work as an iteratee for _map');
  }
}

@include test-module('Sassdash') {
  @include test('_times') {
    @include assert-equal(_times(3, null), 1 2 3,
      'should use _identity when iteratee is nullish');

    @include assert-equal(_times(3), 1 2 3,
      'should use _identity when iteratee is nullish');

    @include assert-equal(_times(3, test-square), 1 4 9,
      'should return a list of the results of each iteratee execution');

    @each $value in $test-falsey {
      @include assert-equal(_times($value), (),
        'should return an empty list for falsey and negative n arguments');
    }

    @include assert-equal(_times(-1), (),
      'should return an empty list for falsey and negative n arguments');

    @include assert-equal(_(3, times), 1 2 3,
      'should be chainable');
  }
}

@include test-module('Sassdash') {
  @include test('_to-list') {
    $map: ('a': 1, 'b': 2, 'c': 3);
    $list: 1 2 3;

    @include assert-equal(_to-list($map), $list,
      'should return the values of maps');

    @include assert-equal(_to-list('abc'), 'a' 'b' 'c',
      'should work with a string for collection');
  }
}

@include test-module('Sassdash') {
  @include test('_trim methods') {
    @each $method-name in 'trim', 'trim-left', 'trim-right' {
      $func: unquote('_#{$method-name}');
      $is-trim-right: $method-name == 'trim-right';
      $is-trim-left: $method-name == 'trim-left';

      $parts: ();
      $parts: if($method-name != 'trim-right', append($parts, 'leading'), $parts);
      $parts: if($method-name != 'trim-left', append($parts, 'trailing'), $parts);
      $parts: _string-join($parts, ' and ');

      $string: ' a b c ';
      $expected: if($is-trim-right, ' ', '') + 'a b c' + if($is-trim-left, ' ', '');

      @include assert-equal(_call($func, null, $string), $expected,
        '#{$func} should remove #{$parts} whitespace');

      @include assert-equal(_call($func, null, 123), '123',
        '#{$func} should coerce string to a string');

      $string: '-_-a-b-c-_-';
      $expected: if($is-trim-right, '-_-', '') + 'a-b-c' + if($is-trim-left, '-_-', '');

      @include assert-equal(_call($func, null, $string, '_-'), $expected,
        '#{$func} should remove #{$parts} chars');

      $string: '121a-b-c121';
      $expected: if($is-trim-right, '121', '') + 'a-b-c' + if($is-trim-left, '121', '');

      @include assert-equal(_call($func, null, $string, 12), $expected,
        '#{$func} should coerce chars to a string');

      @each $value in null, '' {
        @include assert-equal(_call($func, null, $value, '_-'), '',
          '#{$func} should return an empty string when provided null or empty string and chars');

        @include assert-equal(_call($func, null, $value, null), '',
          '#{$func} should return an empty string when provided null or empty string and chars');

        @include assert-equal(_call($func, null, $value, ''), '',
          '#{$func} should return an empty string when provided null or empty string and chars');
      }

      $string: ' abc ';
      $expected: if($is-trim-right, ' ', '') + 'abc' + if($is-trim-left, ' ', '');

      @include assert-equal(_call($func, null, $string, null), $expected,
        '#{$func} should work with null or empty string for chars');

      @include assert-equal(_call($func, null, $string, ''), $string,
        '#{$func} should work with null or empty string for chars');

      $string: ' a b c ';
      $expected: if($is-trim-right, ' ', '') + 'a b c' + if($is-trim-left, ' ', '');

      $actual: _map($string $string $string, $func);

      @include assert-equal($actual, $expected $expected $expected,
        '#{$func} should work as an iteratee for _map');
    }
  }
}

@include test-module('Sassdash') {
  @include test('_unescape') {
    $escaped: '&amp;&lt;&gt;&quot;&#39;&#96;\/';
    $unescaped: '&<>"' + "'`/";

    $escaped: $escaped + $escaped;
    $unescaped: $unescaped + $unescaped;

    @include assert-equal(_unescape('&amp;lt;'), '&lt;',
      'should unescape entities in the correct order');

    @include assert-equal(_unescape($escaped), $unescaped,
      'should unescape the proper entities');

    @include assert-equal(_unescape('abc'), 'abc',
      'should handle strings with nothing to unescape');

    @include assert-equal(_unescape(_escape($unescaped)), $unescaped,
      'should unescape the same characters escaped by _escape');
    
  }
}

@include test-module('Sassdash') {
  @include test('_union') {
    $args: test-args(1, 2, 3);

    @include assert-equal(_union(1 3 2, 5 2 1 4, 2 1), 1 3 2 5 4,
      'should return the union of the given lists');

    @include assert-equal(_union(1 3 2, 1 (5,), 2 (4,)), 1 3 2 (5,) (4,),
      'should not flatten nested lists');

    $list: (0,);

    @include assert-equal(_union($list, 3, null, ('0': 1)), $list,
      'should ignore values that are not lists or arguments objects');

    @include assert-equal(_union(null, $list, null, 2 1), 0 2 1,
      'should ignore values that are not lists or arguments objects');

    @include assert-equal(_union(null, $list, null, $args), 0 1 2 3,
      'should ignore values that are not lists or arguments objects');
  }
}

@function test-uniq-1($map, $args...) {
  @return get($map, 'a');
}
@include test-module('Sassdash') {
  @include test('_uniq') {
    $maps: (
      ( 'a': 2 ),
      ( 'a': 3 ),
      ( 'a': 1 ),
      ( 'a': 2 ),
      ( 'a': 3 ),
      ( 'a': 1 )
    );

    @include assert-equal(_uniq(2 3 1 2 3 1), 2 3 1,
      'should return unique values of an unsorted list');

    @include assert-equal(_uniq(1 1 2 2 3), 1 2 3,
      'should return unique values of a sorted list');

    @include assert-equal(_uniq($maps, test-uniq-1), _slice($maps, 0, 3),
      'should work with an iteratee argument without specifying is-sorted');

    @include assert-equal(_uniq($maps, 'a'), _slice($maps, 0, 3),
      'should work with a _pluck style iteratee');

    $lists: (2 1, 3 1, 1 1, 2 1, 3 1, 1 1);

    @include assert-equal(_uniq($lists, 1), _slice($lists, 0, 3),
      'should work with a _pluck style iteratee');

    $list: (2 1 2, 1 2 1);

    @include assert-equal(_map($list, _uniq), (2 1, 1 2),
      'should perform an unsorted uniq when used as an iteratee for _map');

    @include assert-equal(_uniq('2' 2 3 '2' 3 2), '2' 2 3,
      'should distinguish between numbers and numeric strings');

    @include assert-equal(_unique(2 3 1 2), _uniq(2 3 1 2),
      'should be aliased');
  }
}

@include test-module('Sassdash') {
  @include test('_unique-id') {
    $actual: _times(500, _unique-id);

    @include assert-equal(length(_uniq($actual)), length($actual),
      'should generate unique ids');

    $actual: _unique-id('test-');

    @include assert-equal(_starts-with($actual, 'test-'), true,
      'should prepend prefix to unique id if specified');
  }
}

@include test-module('Sassdash') {
  @include test('_values') {
    $map: ('a': 1, 'b': 2);

    @include assert-equal(_values($map), 1 2,
      'should get the values of a map');
  }
}

@include test-module('Sassdash') {
  @include test('_where') {
    $maps: (
      ( 'a': 1 ),
      ( 'a': 1 ),
      ( 'a': 1, 'b': 2 ),
      ( 'a': 2, 'b': 2 ),
      ( 'a': 3 )
    );

    $pairs: (
      (( 'a': 1 ), (( 'a': 1 ), ( 'a': 1 ), ( 'a': 1, 'b': 2 ))),
      (( 'a': 2 ), (( 'a': 2, 'b': 2 ),)),
      (( 'a': 3 ), (( 'a': 3 ),)),
      (( 'b': 1 ), ()),
      (( 'b': 2 ), (( 'a': 1, 'b': 2 ), ( 'a': 2, 'b': 2 ))),
      (( 'a': 1, 'b': 2 ), (( 'a': 1, 'b': 2 ),))
    );

    @each $pair in $pairs {
      $actual: _where($maps, nth($pair, 1));

      @include assert-equal($actual, nth($pair, 2),
        'should filter by source properties');
    }

    $map: (
      'x': ( 'a': 1 ),
      'y': ( 'a': 3 ),
      'z': ( 'a': 1, 'b': 2 )
    );

    @include assert-equal(_where($map, ('a': 1)), get($map, 'x') get($map, 'z'),
      'should work with a map for collection');

    $list: (
      ('a': 1),
      ('a': 3),
      ('a': 1, 'b': 2)
    );

    $actual: _($list, where ('a': 1), value);

    @include assert-equal($actual, nth($list, 1) nth($list, 3),
      'should work in a lazy chain sequence');
  }
}

@include test-module('Sassdash') {
  @include test('_without') {
    @include assert-equal(_without(1 2 3 1 2 3, 1, 2), 3 3,
      'should remove all occurences of each value from a list');
  }
}

@include test-module('Sassdash') {
  @include test('_words') {
    @include assert-equal(_map('a' 'b' 'c', _words), ('a',) ('b',) ('c',),
      'should work as an iteratee for map');

    @include assert-equal(_words('LETTERSAeiouAreVowels'), 'LETTERS' 'Aeiou' 'Are' 'Vowels',
      'should work with compound words');
    @include assert-equal(_words('aeiouAreVowels'), 'aeiou' 'Are' 'Vowels',
      'should work with compound words');
    @include assert-equal(_words('aeiou2Consonants'), 'aeiou' '2' 'Consonants',
      'should work with compound words');
  }
}

@include test-module('Sassdash') {
  @include test('_xor') {
    @include assert-equal(_xor(1 2 5, 2 3 5, 3 4 5), 1 4 5,
      'should return the symmetric difference of the given lists');

    @include assert-equal(_xor(1 1 2 5, 2 2 3 5, 3 4 5 5), 1 4 5,
      'should return a list of unique values');

    @include assert-equal(_xor(1 1), (1,),
      'should return a list of unique values');

    $list: 1 2;

    @include assert-equal(_xor((0,), 3, null, (1: 2)), (0,),
      'should ignore individual secondary arguments');

    @include assert-equal(_xor($list, 3, null, (1: 2)), $list,
      'should ignore values that are not lists or arguments objects');

    @include assert-equal(_xor(null, $list, null, 2 3), 1 3,
      'should ignore values that are not lists or arglists');

    @include assert-equal(_xor(null, $list, null, test-args(1, 2, 3)), (3,),
      'should ignore values that are not lists or arglists');

    @include assert-equal(_(1 2 3, xor (5 2 1 4)), 3 5 4,
      'should be chainable');
  }
}

@include test-module('Sassdash') {
  @include test('_zip methods') {
    @each $method-name in 'unzip', 'zip' {
      $func: unquote('_#{$method-name}');
      $is-zip: $method-name == 'zip';

      $map: (
        'an empty array': (
          (),
          ()
        ),
        '0-tuples': (
          ((), ()),
          ()
        ),
        '2-tuples': (
          (('barney', 'fred'), (36, 40)),
          (('barney', 36), ('fred', 40))
        ),
        '3-tuples': (
          (('barney', 'fred'), (36, 40), (true, false)),
          (('barney', 36, true), ('fred', 40, false))
        )
      );

      @each $key, $pair in $map {
        $lists: if($is-zip, nth($pair, 1), nth($pair, 2));
        $actual: if($is-zip, _call($func, null, $lists...), _call($func, null, $lists));
        $expected: if($is-zip, nth($pair, 2), if(length($actual) == 0, (), nth($pair, 1)));

        @include assert-equal($actual, $expected,
          '#{$func} should work with #{$key}');
      }
    }
  }
}

@function test-zip-map-1($value, $args...) {
  @return __to-number($value) > 1;
}

@include test-module('Sassdash') {
  @include test('_zip-map') {
    $map: ('barney': 36, 'fred': 40);
    $list: (('barney', 36), ('fred', 40));

    $actual: _zip-map('barney' 'fred', 36 40);
    @include assert-equal($actual, $map,
      'should zip together key/value lists into a map');

    @include assert-equal(_zip-map(('a',), 1 2), ('a': 1),
      'should ignore extra values');

    @include assert-equal(_zip-map($list), $map,
      'should accept a two dimensional list');

    @include assert-equal(_zip-map('barney' 'fred'), ('barney': null, 'fred': null),
      'should not assume keys is two dimensional if values argument is not provided');

    @each $value in $test-falsey {
      @include assert-equal(_zip-map($value), (),
        'should accept a falsey list argument');
    }

    @include assert-equal(_zip-map(_pairs($map)), $map,
      'should support consuming the return value of _pairs');

    $list: ('a' 1, 'b' 2);
    $predicate: test-zip-map-1;
    $actual: _($list, zip-map, map _to-string, filter $predicate, take, value);

    @include assert-equal($actual, ('2',),
      'should work in a lazy chain sequence');

    @include assert-equal(_object($list), _zip-map($list),
      'should be aliased');
  }
}

// @include test-module('Sassdash') {
//   @include test('_shuffle') {
    
//   }
// }
@include report;