@import '../node_modules/bootcamp/dist/_bootcamp';
@import '../scss/_sassdash';

$bc-setting-verbose: true;

@include runner-start;

$test-falsey: ('', 0, false, null);

@include describe('sassdash _after') {
    @include it('should create a function that invokes func after n calls') {
        $test-after: __after(5, length);

        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));

        @include should(expect($result), to(equal(2)));

        $test-after: __after(5, length);

        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));

        @include should(expect($result), to(equal(null)));

        $test-after: __after(0, length);

        $result: __call($test-after, null, (1, 2));

        @include should(expect($result), to(equal(2)));
    }

    @include it('should allow func as the first argument') {
        $test-after: __after(length, 0);

        $result: __call($test-after, null, (1, 2));

        @include should(expect($result), to(equal(2)));
    }
}

@function test-assign-1($a, $b) {
    @return if($a == null, $b, $a);
}
@include describe('_assign') {
    @include it('should assign properties of a source object to the destination object') {
        @include should(expect(_assign(('a': 1), ('b': 2))), to(equal(('a': 1, 'b': 2))));
    }

    @include it('should accept multiple source objects') {
        $expected: ('a': 1, 'b': 2, 'c': 3);

        @include should(expect(_assign(('a': 1), ('b': 2), ('c': 3))), to(equal($expected)));
        @include should(expect(_assign(('a': 1), ('b': 2, 'c': 2), ('c': 3))), to(equal($expected)));
    }

    @include it('should overwrite destination properties') {
        $expected: ('a': 3, 'b': 2, 'c': 1);

        @include should(expect(_assign(('a': 1, 'b': 2), $expected)), to(equal($expected)));
    }

    @include xit('should work with a customizer callback') {
        $actual: _assign(('a': 1, 'b': 2), ('a': 3, 'c': 3), test-assign-1);
        $expected: ('a': 1, 'b': 2, 'c': 3);

        @include should(expect($actual), to(equal($expected)));
    }

    @include xit('should work with a customizer that returns undefined') {
        $expected: ('a': $__undefined__);
        @include should(expect(_assign((), $expected, _identity)), to(equal($expected)));
    }
}

@include describe('_at') {
    $list: ('a', 'b', 'c');
    $map-list: __to-map($list);
    $empty-list: ();

    $map-list: set($map-list, 1.1, 1);

    @include it('should return the elements corresponding to the specified keys') {
        $actual: _at($list, (1 3));
        @include should(expect($actual), to(be(('a' 'c'))));
    }

    @include it('should return null for nonexistent keys') {
        $actual: _at($list, (3 5 1));
        @include should(expect($actual), to(be(('c', null, 'a'))));
    }

    @include it('should return an empty list when no keys are provided') {
        @include should(expect(_at($list)), to(equal($empty-list)));
        @include should(expect(_at($list, (), ())), to(equal($empty-list)));
    }

    @include it('should accept multiple key arguments') {
        $actual: _at(('a' 'b' 'c' 'd'), 4, 1, 3);

        @include should(expect($actual), to(equal('d' 'a' 'c')));
    }

    @include xit('should work with a falsey collection argument when keys are provided') {}

    @include xit('should work with an arguments object for collection') {}

    @include it('should work with an object for collection') {
        $actual: _at(('a': 1, 'b': 2, 'c': 3), ('c' 'a'));
        
        @include should(expect($actual), to(be(3 1)));
    }

    @include xit('should pluck inherited property values') {}

    @include it('should work with a string literal for collection') {
        @include should(expect(_at('abc', 3 1)), to(be('c' 'a')));
    }
}


@include runner-end;