@import '../node_modules/bootcamp/dist/_bootcamp';
@import '../scss/_sassdash';

$bc-setting-verbose: true;

@include runner-start;

$test-falsey: ('', 0, false, null);
$test-empty-list: ();

@function test-add($x, $y) {
    @return $x + $y;
}

@function test-square($n) {
    @return $n * $n;
}

@function test-fixed($n) {
    @return __number-to-fixed($n);
}

@include describe('sassdash _after') {
    @include it('should create a function that invokes func after n calls') {
        $test-after: __after(5, length);

        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));

        @include should(expect($result), to(equal(2)));

        $test-after: __after(5, length);

        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));
        $result: __call($test-after, null, (1, 2));

        @include should(expect($result), to(equal(null)));

        $test-after: __after(0, length);

        $result: __call($test-after, null, (1, 2));

        @include should(expect($result), to(equal(2)));
    }

    @include it('should allow func as the first argument') {
        $test-after: __after(length, 0);

        $result: __call($test-after, null, (1, 2));

        @include should(expect($result), to(equal(2)));
    }
}

@function test-assign-1($a, $b) {
    @return if($a == null, $b, $a);
}
@include describe('_assign') {
    @include it('should assign properties of a source object to the destination object') {
        @include should(expect(_assign(('a': 1), ('b': 2))), to(equal(('a': 1, 'b': 2))));
    }

    @include it('should accept multiple source objects') {
        $expected: ('a': 1, 'b': 2, 'c': 3);

        @include should(expect(_assign(('a': 1), ('b': 2), ('c': 3))), to(equal($expected)));
        @include should(expect(_assign(('a': 1), ('b': 2, 'c': 2), ('c': 3))), to(equal($expected)));
    }

    @include it('should overwrite destination properties') {
        $expected: ('a': 3, 'b': 2, 'c': 1);

        @include should(expect(_assign(('a': 1, 'b': 2), $expected)), to(equal($expected)));
    }

    @include xit('should work with a customizer callback') {
        $actual: _assign(('a': 1, 'b': 2), ('a': 3, 'c': 3), test-assign-1);
        $expected: ('a': 1, 'b': 2, 'c': 3);

        @include should(expect($actual), to(equal($expected)));
    }

    @include xit('should work with a customizer that returns undefined') {
        $expected: ('a': $__undefined__);
        @include should(expect(_assign((), $expected, _identity)), to(equal($expected)));
    }
}

@include describe('_at') {
    $list: ('a', 'b', 'c');
    $map-list: __to-map($list);
    $empty-list: ();

    $map-list: set($map-list, 1.1, 1);

    @include it('should return the elements corresponding to the specified keys') {
        $actual: _at($list, (1 3));
        @include should(expect($actual), to(be(('a' 'c'))));
    }

    @include it('should return null for nonexistent keys') {
        $actual: _at($list, (3 5 1));
        @include should(expect($actual), to(be(('c', null, 'a'))));
    }

    @include it('should return an empty list when no keys are provided') {
        @include should(expect(_at($list)), to(equal($empty-list)));
        @include should(expect(_at($list, (), ())), to(equal($empty-list)));
    }

    @include it('should accept multiple key arguments') {
        $actual: _at(('a' 'b' 'c' 'd'), 4, 1, 3);

        @include should(expect($actual), to(equal('d' 'a' 'c')));
    }

    @include xit('should work with a falsey collection argument when keys are provided') {}

    @include xit('should work with an arguments object for collection') {}

    @include it('should work with an object for collection') {
        $actual: _at(('a': 1, 'b': 2, 'c': 3), ('c' 'a'));
        
        @include should(expect($actual), to(be(3 1)));
    }

    @include xit('should pluck inherited property values') {}

    @include it('should work with a string literal for collection') {
        @include should(expect(_at('abc', 3 1)), to(be('c' 'a')));
    }
}

@include xdescribe('_attempt') {}

$test-before-count: 0 !global;
@function test-before-1() {
    $test-before-count: $test-before-count + 1 !global;

    @return $test-before-count;
}
@include describe('_before') {
    @include it('should create a function that invokes func after n calls') {
        // before(n) should invoke `func` before being called `n` times
        $test-before-count: 0 !global;
        $test-before: _before(5, test-before-1);

        $_: _call($test-before);
        $_: _call($test-before);
        $_: _call($test-before);
        $_: _call($test-before);

        @include should(expect($test-before-count), to(equal(4)));

        // before(n) should not invoke `func` after being called `n - 1` times
        $test-before-count: 0 !global;
        $test-before: _before(5, test-before-1);

        $_: _call($test-before);
        $_: _call($test-before);
        $_: _call($test-before);
        $_: _call($test-before);
        $_: _call($test-before);
        $_: _call($test-before);

        @include should(expect($test-before-count), to(equal(4)));
        
        // before(0) should not invoke `func` immediately
        $test-before-count: 0 !global;
        $test-before: _before(0, test-before-1);

        @include should(expect($test-before-count), to(equal(0)));

        // before(0) should not invoke `func` when called
        $test-before-count: 0 !global;
        $test-before: _before(0, test-before-1);

        $_: _call($test-before);

        @include should(expect($test-before-count), to(equal(0)));
    }

    @include xit('should coerce non-finite n values to 0') {}

    @include it('should allow func as the first argument') {
        $test-before-count: 0 !global;

        $test-before: _before(test-before-1, 2);

        $_: _call($test-before);
        $_: _call($test-before);

        @include should(expect($test-before-count), to(equal(1)));
    }

    @include xit('should not set a this binding') {}
}

@include xdescribe('_bind') {}

@include xdescribe('_bind-all') {}

@include xdescribe('_bind-key') {}

@include describe('case methods') {
    $strings: (
        'foo bar', 'Foo bar', 'foo Bar', 'Foo Bar',
        'FOO BAR', 'fooBar', '--foo-bar', '__foo_bar__'
    );

    $converted: (
        'camel': 'fooBar',
        'kebab': 'foo-bar',
        'snake': 'foo_bar',
        'start': 'Foo Bar'
    );

    @each $case-name in ('camel' 'kebab' 'snake' 'start') {
        $method-name: '_' + $case-name + '-case';
        
        @include it('should convert string to #{$case-name} case') {
            @each $string in $strings {
                $actual: call($method-name, $string);
                $expected: if($case-name == 'start' and $string == 'FOO BAR', $string, get($converted, $case-name));

                @include should(expect($actual), to(equal($expected)));
            }
        }

        @include it('#{$method-name} should handle double-converting strings') {
            @each $string in $strings {
                $actual: call($method-name, call($method-name, $string));
                $expected: if($case-name == 'start' and $string == 'FOO BAR', $string, get($converted, $case-name));

                @include should(expect($actual), to(equal($expected)));
            }
        }

        @include xit('#{$method-name} should deburr letters') {}

        @include xit('#{$method-name} should trim latin-1 mathematical operators') {}

        @include xit('#{$method-name} should coerce string to a string') {}

        @include it('#{$method-name} should return an unwrapped value when chaining') {
            $actual: _('foo bar', $case-name + '-case');
            $expected: get($converted, $case-name);

            @include should(expect($actual), to(equal($expected)));
        }
    }
}

// @include xdescribe('_camel-case') {
//     @include it('should work with numbers') {
//         @include should(expect(_camel-case('too legit 2 quit')), to(equal('tooLegit2Quit')));
//         @include should(expect(_camel-case('walk 500 miles')), to(equal('walk500Miles')));
//         @include should(expect(_camel-case('xhr2 request')), to(equal('xhr2Request')));
//     }
// }

@include describe('_capitalize') {
    @include it('should capitalize the first character of a string') {
        @include should(expect(_capitalize('fred')), to(equal('Fred')));
        @include should(expect(_capitalize('Fred')), to(equal('Fred')));
        @include should(expect(_capitalize(' fred')), to(equal(' fred')));
    }

    @include it('should return an unwrapped value when chaining') {
        @include should(expect(_('fred', capitalize)), to(equal('Fred')));
    }
}

@include describe('_chain') {
    @include it('should return a wrapped value') {
        $actual: _chain(('a': 0));

        @include should(expect(instanceof($actual, SassdashWrapper)), to(be(true)));
    }

    @include it('should return existing wrapped values') {
        $wrapped: _chain(('a': 0));

        @include should(expect(_chain($wrapped)), to(equal($wrapped)));
        @include should(expect(_($wrapped, chain)), to(equal($wrapped)));
    }

    @include xit('should enable chaining of methods that return unwrapped values by default') {}

    @include xit('should chain multiple methods') {}
}

@include describe('_chunk') {
    $list: (0 1 2 3 4 5);

    @include it('should return chunked arrays') {
        $actual: _chunk($list, 3);
        $expected: ((0 1 2) (3 4 5));

        @include should(expect($actual), to(be($expected)));
    }

    @include it('should return the last chunk as remaining elements') {
        $actual: _chunk($list, 4);
        $expected: ((0 1 2 3) (4 5));

        @include should(expect($actual), to(be($expected)));
    }

    @include it('should ensure the minimum chunkSize is one') {
        @each $value in append($test-falsey, -1) {        
            $actual: _chunk($list, $value);
            $expected: (0,) (1,) (2,) (3,) (4,) (5,);

            @include should(expect($actual), to(be($expected)));
        }
    }

    @include it('should work as an iteratee for _map') {
        $actual: _map(((1 2) (3 4)), _chunk);
        $expected: (((1,) (2,)) ((3,) (4,)));

        @include should(expect($actual), to(be($expected)));
    }
}

@include xdescribe('_clone') {}

@include describe('_compact') {
    @include it('should filter falsey values') {
        $list: join('0' '1' '2', $test-falsey);
        $actual: _compact($list);
        $expected: ('0' '1' '2');

        @include should(expect($actual), to(be($expected)));
    }

    @include xit('should return a wrapped value when chaining') {}

    @include it('should work when in between lazy operators') {
        $actual: _($test-falsey, slice, compact, slice, value);

        @include should(expect(length($actual)), to(be(0)));

        $actual: _($test-falsey, slice, push true 1, compact, push 'a', slice, value);
        $expected: (true, 1, 'a');

        @include should(expect($actual), to(be($expected)));
    }
}

@include describe('_flow-right') {
    @include xit('should be aliased') {}
}

@include describe('flow methods') {
    @each $method-name in ('flow', 'flow-right') {
        $func: unquote('_#{$method-name}');
        $is-flow: ($method-name == 'flow');

        @include it('#{$func} should supply each function with the return value of the previous') {
            $combined: if($is-flow, call($func, test-add, test-square, test-fixed), call($func, test-fixed, test-square, test-add));

            $actual: _call($combined, null, 1, 2);
            $expected: 9.0;

            @include should(expect($actual), to(be($expected)));
        }

        @include it('#{$func} should return a new function') {
            @include should(expect(_call($func, null, _noop)), not-to(equal(_noop)));
        }

        @include it('#{$func} should return a noop function when no arguments are provided') {
            $combined: call($func);

            @include should(expect(_call($combined)), to(equal(_call(_noop))));
        }

        @include xit('#{$func} should return a wrapped value when chaining') {}
    }
}

@include describe('_constant') {
    @include it('should create a function that returns value') {
        $constant: _constant(('a': 1));
        $actual: _call($constant);
        $expected: ('a': 1);

        @include should(expect($actual), to(be($expected)));
    }

    @include it('should work with falsey values') {
        @each $value in $test-falsey {        
            $constant: _constant($value);
            $actual: _call($constant);
            $expected: $value;

            @include should(expect($actual), to(be($expected)));
        }

        $constant: _constant();
        $actual: _call($constant);
        $expected: null;

        @include should(expect($actual), to(be($expected)));    
    }

    @include xit('should return a wrapped value when chaining') {}
}

@function test-count-by-1($value, $args...) {
    @return floor($value);
}
@function test-count-by-2($value, $args...) {
    @return $value > 1;
}
@include describe('_count-by') {
    $list: (4.2, 6.1, 6.4);

    // @include it('should work with an iteratee') {
    //     $actual: _count-by($list, test-count-by-1);
    //     $expected: (4: 1, 6: 2);

    //     @include should(expect($actual), to(equal($expected)));
    // }

    // @include it('should use _identity when iteratee is null') {
    //     $list: (4, 6, 6);
    //     $actual: _count-by($list, null);
    //     $expected: (4: 1, 6: 2);

    //     @include should(expect($actual), to(be($expected)));

    //     $actual: _count-by($list);

    //     @include should(expect($actual), to(be($expected)));
    // }

    // @include xit('should provide the correct iteratee arguments') {}

    // @include xit('should support the this-arg argument') {}

    // @include xit('should only add values to own, not inherited, properties') {}

    // @include it('should work with a _pluck style iteratee') {
    //     $map: (
    //         (a: 'one', len: 3),
    //         (a: 'two', len: 3),
    //         (a: 'three', len: 5),
    //     );
    //     $actual: _count-by($map, 'len');
    //     $expected: (3: 2, 5: 1);

    //     @include should(expect($actual), to(be($expected)));
    // }

    @include xit('should work with a number for iteratee') {
        // todo
        $list: (1 'a', 2 'a', 2 'b');
        $actual: _count-by($list, 1);
        $expected: (1: 1, 2: 2);

        @debug $actual;

        @include should(expect($actual), to(be($expected)));
    }

    @include it('should work with an object for collection') {
        $actual: _count-by(('a': 4.2, 'b': 6.1, 'c': 6.4), test-count-by-1);
        $expected: (4: 1, 6: 2);

        @include should(expect($actual), to(be($expected)));
    }

    @include it('should work in a lazy chain sequence') {
        $list: (1 2 1 3);
        @debug _($list, count-by _identity, map _to-string, filter test-count-by-2);
        $actual: _($list, count-by _identity, map _to-string, filter test-count-by-2, take);
        $expected: (2,);

        @include should(expect($actual), to(be($expected)));
    }
}

@include describe('a') {
    @include it('a') {
        $actual: null;
        $expected: null;

        @include should(expect($actual), to(be($expected)));
    }
}

























@include runner-end;